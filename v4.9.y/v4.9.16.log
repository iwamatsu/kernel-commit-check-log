Check from v4.9.16 to v4.9.17
Commit count: 94
checking c3825da143fc419e2639e602f62d793ed0de4657 ......
checking ecdc5b12d7a01707b5b3f334cdf47f01e50d2ce3 ......
	 orig commit -> aa2be9b3d6d2d699e9ca7cbfc00867c80e5da213 ......
checking c40609652267440ae6f800303ea1f3be17d357e2 ......
	 orig commit -> 17fcbd590d0c3e35bd9646e2215f86586378bc42 ......
		 17fcbd590d0c3e35bd9646e2215f86586378bc42 has problem. Fixes commit -> a0c4acd2c220376b4e9690e75782d0c0afdaab9f
commit 5497d74e75f8b33bc0777d3550c0159b66f0d3fa
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Fri Jun 16 16:44:34 2017 +0300

    locking/rwsem-spinlock: Fix EINTR branch in __down_write_common()
    
    commit a0c4acd2c220376b4e9690e75782d0c0afdaab9f upstream.
    
    If a writer could been woken up, the above branch
    
            if (sem->count == 0)
                    break;
    
    would have moved us to taking the sem. So, it's
    not the time to wake a writer now, and only readers
    are allowed now. Thus, 0 must be passed to __rwsem_do_wake().
    
    Next, __rwsem_do_wake() wakes readers unconditionally.
    But we mustn't do that if the sem is owned by writer
    in the moment. Otherwise, writer and reader own the sem
    the same time, which leads to memory corruption in
    callers.
    
    rwsem-xadd.c does not need that, as:
    
      1) the similar check is made lockless there,
      2) in __rwsem_mark_wake::try_reader_grant we test,
    
    that sem is not owned by writer.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Niklas Cassel <niklas.cassel@axis.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 17fcbd590d0c "locking/rwsem: Fix down_write_killable() for CONFIG_RWSEM_GENERIC_SPINLOCK=y"
    Link: http://lkml.kernel.org/r/149762063282.19811.9129615532201147826.stgit@localhost.localdomain
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 1522181f4bc14a61c72981439fcbe9a87496f3cf ......
	 orig commit -> 9bbb25afeb182502ca4f2c4f3f88af0681b34cae ......
checking 6244ffc5a1221e593a937c7ad3c03a9ce691a8df ......
	 orig commit -> c236c8e95a3d395b0494e7108f0d41cf36ec107c ......
checking 9f9115b67aa5821e1d5490d94c1ad87d0396f7b6 ......
	 orig commit -> 5dc855d44c2ad960a86f593c60461f1ae1566b6d ......
checking 24ba2842a49da3338581b42a5618088d2a0b0730 ......
	 orig commit -> be3606ff739d1c1be36389f8737c577ad87e1f57 ......
checking 5ec98e6ffdce5eb5dbe3593df2aa824d04d70842 ......
	 orig commit -> 44fee88cea43d3c2cac962e0439cb10a3cabff6d ......
checking 095635be809ade2429c844d09e8391330fa9bca4 ......
	 orig commit -> 90922a2d03d84de36bf8a9979d62580102f31a92 ......
checking 61e79860b4bc6259a9685a107a6b34352d6dc7bd ......
	 orig commit -> 68925176296a8b995e503349200e256674bfe5ac ......
checking 8ca7ef0d9af9644a65e3e22ccc1937f00caa777b ......
	 orig commit -> ab8df60e3a3b68420d0d4477c5f07c00fbfb078b ......
checking 6b3306706733cc98bf14e30ff54fa9084b76cd55 ......
	 orig commit -> 26fc78f6fef39b9d7a15def5e7e9826ff68303f4 ......
checking f4d40cfd61ea6e99f965576d19b76b42fd371365 ......
	 orig commit -> f2a46926aba1f0c33944901d2420a6a887455ddc ......
checking 7885195b9177042aea3da65c4789790f8e788aa6 ......
	 orig commit -> a05ef161cdd22faccffe06f21fc8f1e249565385 ......
checking ce7aeffe7596343fce49307f374444b199b950a1 ......
	 orig commit -> 32856eea7bf75dfb99b955ada6e147f553a11366 ......
checking 4fa1c65cf040a933ee8d2d0d1c0df83361add7ab ......
	 orig commit -> f209fa03fc9d131b3108c2e4936181eabab87416 ......
		 f209fa03fc9d131b3108c2e4936181eabab87416 has problem. Fixes commit -> c130b666a9a711f985a0a44b58699ebe14bb7245
commit 1bf9bc48133851121d92f0cc908bb5a1446aeba5
Author: Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
Date:   Wed Dec 28 16:42:00 2016 -0200

    8250_pci: Fix potential use-after-free in error path
    
    commit c130b666a9a711f985a0a44b58699ebe14bb7245 upstream.
    
    Commit f209fa03fc9d ("serial: 8250_pci: Detach low-level driver during
    PCI error recovery") introduces a potential use-after-free in case the
    pciserial_init_ports call in serial8250_io_resume fails, which may
    happen if a memory allocation fails or if the .init quirk failed for
    whatever reason).  If this happen, further pci_get_drvdata will return a
    pointer to freed memory.
    
    This patch reworks the PCI recovery resume hook to restore the old priv
    structure in this case, which should be ok, since the ports were already
    detached. Such error during recovery causes us to give up on the
    recovery.
    
    Fixes: f209fa03fc9d ("serial: 8250_pci: Detach low-level driver during PCI error recovery")
    Reported-by: Michal Suchanek <msuchanek@suse.com>
    Signed-off-by: Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 56c28e7983a8c877e99de0152ce3f7f5eea98963 ......
	 orig commit -> 708f5dcc21ae9b35f395865fc154b0105baf4de4 ......
checking 5c19e9070df8165db7ba26c13f39848d94e2ce8a ......
	 orig commit -> 9523b9bf6dceef6b0215e90b2348cd646597f796 ......
checking bc01eb939899762eede303ffbbbfcda197316234 ......
	 orig commit -> 89e364db71fb5e7fc8d93228152abfa67daf35fa ......
checking bd2de45031b9b05738c91b87c1c360471c075bbd ......
	 orig commit -> e950267ab802c8558f1100eafd4087fd039ad634 ......
checking e627116c0c35d3d42fb031683606a49ce7d63cc5 ......
	 orig commit -> b3e8652bcbfa04807e44708d4d0c8cdad39c9215 ......
checking 61a153d06ef4ce17bf2a200dc6e7247dc3b56a57 ......
	 orig commit -> 25cdb64510644f3e854d502d69c73f21c6df88a9 ......
checking 0042afe117c69e41511e22c15994e853a856e10f ......
	 orig commit -> 2a32b9b1866a2ee9f01fbf2a48d99012f0120739 ......
checking 5001756c1c70ab555d4d3ca6965547ac02410d4b ......
	 orig commit -> 4391d7f5c79a9fe6fa11cf6c160ca7f7bdb49d2a ......
checking ddc23b5212b9cfa2e4f802bd95e365e63a6b2cc7 ......
	 orig commit -> e50fcff15fe120ef2103a9e18af6644235c2b14d ......
		 e50fcff15fe120ef2103a9e18af6644235c2b14d has problem. Fixes commit -> a90e049cacd965dade4dae7263b4d3fd550e78b6
commit 34da5f74eb5caf1ae3873463aa5e2b801fa450c3
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Wed Jun 28 08:24:45 2017 -0400

    drm/nouveau/disp/nv50-: bump max chans to 21
    
    commit a90e049cacd965dade4dae7263b4d3fd550e78b6 upstream.
    
    GP102's cursors go from chan 17..20. Increase the array size to hold
    their data properly.
    
    Fixes: e50fcff15f ("drm/nouveau/disp/gp102: fix cursor/overlay immediate channel indices")
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 53e18968a9c0753e542cc4f6b0cc2da5db64ffd9 ......
	 orig commit -> d9c728949ddc9de5734bf3b12ea906ca8a77f2a0 ......
		 d9c728949ddc9de5734bf3b12ea906ca8a77f2a0 has problem. Fixes commit -> 2da64d20a0b20046d688e44f4033efd09157e29d
commit 3e550debcf7557ca966388d5462519063aa75524
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Wed Feb 1 14:26:16 2017 +1100

    vfio/spapr: Fix missing mutex unlock when creating a window
    
    
    [ Upstream commit 2da64d20a0b20046d688e44f4033efd09157e29d ]
    
    Commit d9c728949ddc ("vfio/spapr: Postpone default window creation")
    added an additional exit to the VFIO_IOMMU_SPAPR_TCE_CREATE case and
    made it possible to return from tce_iommu_ioctl() without unlocking
    container->lock; this fixes the issue.
    
    Fixes: d9c728949ddc ("vfio/spapr: Postpone default window creation")
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 2e60baca235b05d4026207e31b6fc385c0c1c122 ......
	 orig commit -> 6f01cc692a16405235d5c34056455b182682123c ......
		 6f01cc692a16405235d5c34056455b182682123c has problem. Fixes commit -> 930a42ded3fede7ca3acafc9153f4f2d0f56a92c
commit d536202202eef1102a90ece32d91c20dffdbeede
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Tue May 23 21:53:51 2017 -0400

    vfio/spapr_tce: Set window when adding additional groups to container
    
    
    [ Upstream commit 930a42ded3fede7ca3acafc9153f4f2d0f56a92c ]
    
    If a container already has a group attached, attaching a new group
    should just program already created IOMMU tables to the hardware via
    the iommu_table_group_ops::set_window() callback.
    
    However commit 6f01cc692a16 ("vfio/spapr: Add a helper to create
    default DMA window") did not just simplify the code but also removed
    the set_window() calls in the case of attaching groups to a container
    which already has tables so it broke VFIO PCI hotplug.
    
    This reverts set_window() bits in tce_iommu_take_ownership_ddw().
    
    Fixes: 6f01cc692a16 ("vfio/spapr: Add a helper to create default DMA window")
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 080eb13542a853b0ee6061f17bf124079d08e64e ......
	 orig commit -> 4b6fad7097f883335b6d9627c883cb7f276d94c9 ......
		 4b6fad7097f883335b6d9627c883cb7f276d94c9 has problem. Fixes commit -> 3393af24b665cb0aea7353b05e522b03ab1e7d73
commit bab8ac1b274eb835a6ac33501dbd010fc0262822
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Mon Mar 27 14:23:40 2017 +1100

    vfio/spapr_tce: Check kzalloc() return when preregistering memory
    
    
    [ Upstream commit 3393af24b665cb0aea7353b05e522b03ab1e7d73 ]
    
    This adds missing checking for kzalloc() return value.
    
    Fixes: 4b6fad7097f8 ("powerpc/mm/iommu, vfio/spapr: Put pages on VFIO container shutdown")
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 92e44bcd71ae5ae2f6d259963caf0b134243caad ......
	 orig commit -> bc82d122ae4a0e9f971f13403995898fcfa0c09e ......
checking 5b34666bd2e70046f9880db01119c7d908e0888d ......
	 orig commit -> d7baee6901b34c4895eb78efdbf13a49079d7404 ......
checking 2ba7ef21820ec5cb2376078774e24d6f6a7386b2 ......
	 orig commit -> 88f54a3581eb9deaa3bd1aade40aef266d782385 ......
checking 5d8b3e755974494296e4a2c5874c04aba9532566 ......
	 orig commit -> 39701e56f5f16ea0cf8fc9e8472e645f8de91d23 ......
checking 3c0cbb47a8d634978225a52764691096a7fc1468 ......
	 orig commit -> fa32ff6576623616c1751562edaed8c164ca5199 ......
checking 3e5a7f5b95f00bf69e93a3b7019355ced807c3d0 ......
	 orig commit -> 94acf164dc8f1184e8d0737be7125134c2701dbe ......
checking fb7c521a1460ad46a17859274d79f30599bdb5ea ......
	 orig commit -> f40ec3c748c6912f6266c56a7f7992de61b255ed ......
checking 3d58444dea81ba0556ffcb356a19fc2d224d4eac ......
	 orig commit -> 63880b230a4af502c56dde3d4588634c70c66006 ......
checking 74cce811a4b60d64c5c30496f326ecd18a72a6b2 ......
	 orig commit -> 45d004f4afefdd8d79916ee6d97a9ecd94bb1ffe ......
checking a38012dc69eb2fb1a660bbc88e98c882b5cf2fcb ......
	 orig commit -> 546ba9f8f22f71b0202b6ba8967be5cc6dae4e21 ......
checking bb479246bb3ee7d8f4b1caada0db9a268e958f1e ......
	 orig commit -> 7a6d312b50e63f598f5b5914c4fd21878ac2b595 ......
checking ed09d211d28e260e81b857e1933e43a3f230cf34 ......
	 orig commit -> 0b457dde3cf8b7c76a60f8e960f21bbd4abdc416 ......
checking 7b65c3a84311026200b19eb86c9a76ff004402f8 ......
	 orig commit -> 286c2378aaccc7343ebf17ec6cd86567659caf70 ......
checking 6a5f3e664ac798b54448fc55e7e7c3a9fd1ee9d4 ......
	 orig commit -> 6ffa2489c51da77564a0881a73765ea2169f955d ......
checking 29d928785f5e76b5abfafe4a91cc1db4155cd677 ......
	 orig commit -> 59107e2f48831daedc46973ce4988605ab066de3 ......
checking 456be98b4e79a2ed0316bbc0e885c526cbe8afad ......
	 orig commit -> 8bf11557d44d00562360d370de8aa70ba89aa0d5 ......
checking 94700877c25f64cc3660b0f72c0a8f2165f5c696 ......
	 orig commit -> c9b3379f60a83288a5e2f8ea75476460978689b0 ......
checking 189491f81cf639d2d0292334580b9969c8a424df ......
	 orig commit -> 79fac9c9b74f4951c9ce82b22e714bcc34ae4a56 ......
checking 4d36f4859fa443e02e7834b9a5ce01b63f7af2c3 ......
	 orig commit -> 7435b32e2d2fb5da6c2ae9b9c8ce56d8a3cb3bc3 ......
checking 29022860df8efabdf0a2d356fd614d4dba2791a5 ......
	 orig commit -> 9c93cf03d4eb3dc58931ff7cac0af9c344fe5e0b ......
checking 0ad1d7660a57152ab6c7ae8ff5d02b6460b281a8 ......
	 orig commit -> 11950d70b52d2bc5e3580da8cd63909ef38d67db ......
checking 61229e62c1aa4d397aab9949325cab49acfd7dab ......
	 orig commit -> 5bc8c230e2a993b49244f9457499f17283da9ec7 ......
checking 15ffc931eeb94d9673c2a163828704a7cf4c1df5 ......
	 orig commit -> 4e684f59d760a2c7c716bb60190783546e2d08a1 ......
checking 4b40611a9b7e5d06626674af898608167ac3f727 ......
	 orig commit -> c74fd80f2f41d05f350bb478151021f88551afe8 ......
checking 2382c1486c62a21d162f0d457c61cd87a2498ffd ......
	 orig commit -> 21d25f6a4217e755906cb548b55ddab39d0e88b9 ......
checking 0e0f1d6fdb353fc886ee99d646c561e4ad3d4ebc ......
	 orig commit -> 6760bf2ddde8ad64f8205a651223a93de3a35494 ......
checking 1889d6d9b5e767c7070ad31f93371dcb05b0cea4 ......
	 orig commit -> a08dd0da5307ba01295c8383923e51e7997c3576 ......
checking b7f5aa1ca0bedbd109be7563f6a94c9a37714537 ......
	 orig commit -> d2a4dd37f6b41fbcad76efbf63124eb3126c66fe ......
checking 1411707acb85c514c603f692327c98db48127900 ......
	 orig commit -> 57a09bf0a416700676e77102c28f9cfcb48267e0 ......
		 57a09bf0a416700676e77102c28f9cfcb48267e0 has problem. Fixes commit -> 6760bf2ddde8ad64f8205a651223a93de3a35494
a08dd0da5307ba01295c8383923e51e7997c3576
d2a4dd37f6b41fbcad76efbf63124eb3126c66fe
commit 0e0f1d6fdb353fc886ee99d646c561e4ad3d4ebc
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Sun Dec 18 01:52:59 2016 +0100

    bpf: fix mark_reg_unknown_value for spilled regs on map value marking
    
    [ Upstream commit 6760bf2ddde8ad64f8205a651223a93de3a35494 ]
    
    Martin reported a verifier issue that hit the BUG_ON() for his
    test case in the mark_reg_unknown_value() function:
    
      [  202.861380] kernel BUG at kernel/bpf/verifier.c:467!
      [...]
      [  203.291109] Call Trace:
      [  203.296501]  [<ffffffff811364d5>] mark_map_reg+0x45/0x50
      [  203.308225]  [<ffffffff81136558>] mark_map_regs+0x78/0x90
      [  203.320140]  [<ffffffff8113938d>] do_check+0x226d/0x2c90
      [  203.331865]  [<ffffffff8113a6ab>] bpf_check+0x48b/0x780
      [  203.343403]  [<ffffffff81134c8e>] bpf_prog_load+0x27e/0x440
      [  203.355705]  [<ffffffff8118a38f>] ? handle_mm_fault+0x11af/0x1230
      [  203.369158]  [<ffffffff812d8188>] ? security_capable+0x48/0x60
      [  203.382035]  [<ffffffff811351a4>] SyS_bpf+0x124/0x960
      [  203.393185]  [<ffffffff810515f6>] ? __do_page_fault+0x276/0x490
      [  203.406258]  [<ffffffff816db320>] entry_SYSCALL_64_fastpath+0x13/0x94
    
    This issue got uncovered after the fix in a08dd0da5307 ("bpf: fix
    regression on verifier pruning wrt map lookups"). The reason why it
    wasn't noticed before was, because as mentioned in a08dd0da5307,
    mark_map_regs() was doing the id matching incorrectly based on the
    uncached regs[regno].id. So, in the first loop, we walked all regs
    and as soon as we found regno == i, then this reg's id was cleared
    when calling mark_reg_unknown_value() thus that every subsequent
    register was probed against id of 0 (which, in combination with the
    PTR_TO_MAP_VALUE_OR_NULL type is an invalid condition that no other
    register state can hold), and therefore wasn't type transitioned such
    as in the spilled register case for the second loop.
    
    Now since that got fixed, it turned out that 57a09bf0a416 ("bpf:
    Detect identical PTR_TO_MAP_VALUE_OR_NULL registers") used
    mark_reg_unknown_value() incorrectly for the spilled regs, and thus
    hitting the BUG_ON() in some cases due to regno >= MAX_BPF_REG.
    
    Although spilled regs have the same type as the non-spilled regs
    for the verifier state, that is, struct bpf_reg_state, they are
    semantically different from the non-spilled regs. In other words,
    there can be up to 64 (MAX_BPF_STACK / BPF_REG_SIZE) spilled regs
    in the stack, for example, register R<x> could have been spilled by
    the program to stack location X, Y, Z, and in mark_map_regs() we
    need to scan these stack slots of type STACK_SPILL for potential
    registers that we have to transition from PTR_TO_MAP_VALUE_OR_NULL.
    Therefore, depending on the location, the spilled_regs regno can
    be a lot higher than just MAX_BPF_REG's value since we operate on
    stack instead. The reset in mark_reg_unknown_value() itself is
    just fine, only that the BUG_ON() was inappropriate for this. Fix
    it by making a __mark_reg_unknown_value() version that can be
    called from mark_map_reg() generically; we know for the non-spilled
    case that the regno is always < MAX_BPF_REG anyway.
    
    Fixes: 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    Reported-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1889d6d9b5e767c7070ad31f93371dcb05b0cea4
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Dec 15 01:30:06 2016 +0100

    bpf: fix regression on verifier pruning wrt map lookups
    
    [ Upstream commit a08dd0da5307ba01295c8383923e51e7997c3576 ]
    
    Commit 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL
    registers") introduced a regression where existing programs stopped
    loading due to reaching the verifier's maximum complexity limit,
    whereas prior to this commit they were loading just fine; the affected
    program has roughly 2k instructions.
    
    What was found is that state pruning couldn't be performed effectively
    anymore due to mismatches of the verifier's register state, in particular
    in the id tracking. It doesn't mean that 57a09bf0a416 is incorrect per
    se, but rather that verifier needs to perform a lot more work for the
    same program with regards to involved map lookups.
    
    Since commit 57a09bf0a416 is only about tracking registers with type
    PTR_TO_MAP_VALUE_OR_NULL, the id is only needed to follow registers
    until they are promoted through pattern matching with a NULL check to
    either PTR_TO_MAP_VALUE or UNKNOWN_VALUE type. After that point, the
    id becomes irrelevant for the transitioned types.
    
    For UNKNOWN_VALUE, id is already reset to 0 via mark_reg_unknown_value(),
    but not so for PTR_TO_MAP_VALUE where id is becoming stale. It's even
    transferred further into other types that don't make use of it. Among
    others, one example is where UNKNOWN_VALUE is set on function call
    return with RET_INTEGER return type.
    
    states_equal() will then fall through the memcmp() on register state;
    note that the second memcmp() uses offsetofend(), so the id is part of
    that since d2a4dd37f6b4 ("bpf: fix state equivalence"). But the bisect
    pointed already to 57a09bf0a416, where we really reach beyond complexity
    limit. What I found was that states_equal() often failed in this
    case due to id mismatches in spilled regs with registers in type
    PTR_TO_MAP_VALUE. Unlike non-spilled regs, spilled regs just perform
    a memcmp() on their reg state and don't have any other optimizations
    in place, therefore also id was relevant in this case for making a
    pruning decision.
    
    We can safely reset id to 0 as well when converting to PTR_TO_MAP_VALUE.
    For the affected program, it resulted in a ~17 fold reduction of
    complexity and let the program load fine again. Selftest suite also
    runs fine. The only other place where env->id_gen is used currently is
    through direct packet access, but for these cases id is long living, thus
    a different scenario.
    
    Also, the current logic in mark_map_regs() is not fully correct when
    marking NULL branch with UNKNOWN_VALUE. We need to cache the destination
    reg's id in any case. Otherwise, once we marked that reg as UNKNOWN_VALUE,
    it's id is reset and any subsequent registers that hold the original id
    and are of type PTR_TO_MAP_VALUE_OR_NULL won't be marked UNKNOWN_VALUE
    anymore, since mark_map_reg() reuses the uncached regs[regno].id that
    was just overridden. Note, we don't need to cache it outside of
    mark_map_regs(), since it's called once on this_branch and the other
    time on other_branch, which are both two independent verifier states.
    A test case for this is added here, too.
    
    Fixes: 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b7f5aa1ca0bedbd109be7563f6a94c9a37714537
Author: Alexei Starovoitov <ast@fb.com>
Date:   Wed Dec 7 10:57:59 2016 -0800

    bpf: fix state equivalence
    
    [ Upstream commit d2a4dd37f6b41fbcad76efbf63124eb3126c66fe ]
    
    Commmits 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    and 484611357c19 ("bpf: allow access into map value arrays") by themselves
    are correct, but in combination they make state equivalence ignore 'id' field
    of the register state which can lead to accepting invalid program.
    
    Fixes: 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    Fixes: 484611357c19 ("bpf: allow access into map value arrays")
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 0e0f1d6fdb353fc886ee99d646c561e4ad3d4ebc
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Sun Dec 18 01:52:59 2016 +0100

    bpf: fix mark_reg_unknown_value for spilled regs on map value marking
    
    [ Upstream commit 6760bf2ddde8ad64f8205a651223a93de3a35494 ]
    
    Martin reported a verifier issue that hit the BUG_ON() for his
    test case in the mark_reg_unknown_value() function:
    
      [  202.861380] kernel BUG at kernel/bpf/verifier.c:467!
      [...]
      [  203.291109] Call Trace:
      [  203.296501]  [<ffffffff811364d5>] mark_map_reg+0x45/0x50
      [  203.308225]  [<ffffffff81136558>] mark_map_regs+0x78/0x90
      [  203.320140]  [<ffffffff8113938d>] do_check+0x226d/0x2c90
      [  203.331865]  [<ffffffff8113a6ab>] bpf_check+0x48b/0x780
      [  203.343403]  [<ffffffff81134c8e>] bpf_prog_load+0x27e/0x440
      [  203.355705]  [<ffffffff8118a38f>] ? handle_mm_fault+0x11af/0x1230
      [  203.369158]  [<ffffffff812d8188>] ? security_capable+0x48/0x60
      [  203.382035]  [<ffffffff811351a4>] SyS_bpf+0x124/0x960
      [  203.393185]  [<ffffffff810515f6>] ? __do_page_fault+0x276/0x490
      [  203.406258]  [<ffffffff816db320>] entry_SYSCALL_64_fastpath+0x13/0x94
    
    This issue got uncovered after the fix in a08dd0da5307 ("bpf: fix
    regression on verifier pruning wrt map lookups"). The reason why it
    wasn't noticed before was, because as mentioned in a08dd0da5307,
    mark_map_regs() was doing the id matching incorrectly based on the
    uncached regs[regno].id. So, in the first loop, we walked all regs
    and as soon as we found regno == i, then this reg's id was cleared
    when calling mark_reg_unknown_value() thus that every subsequent
    register was probed against id of 0 (which, in combination with the
    PTR_TO_MAP_VALUE_OR_NULL type is an invalid condition that no other
    register state can hold), and therefore wasn't type transitioned such
    as in the spilled register case for the second loop.
    
    Now since that got fixed, it turned out that 57a09bf0a416 ("bpf:
    Detect identical PTR_TO_MAP_VALUE_OR_NULL registers") used
    mark_reg_unknown_value() incorrectly for the spilled regs, and thus
    hitting the BUG_ON() in some cases due to regno >= MAX_BPF_REG.
    
    Although spilled regs have the same type as the non-spilled regs
    for the verifier state, that is, struct bpf_reg_state, they are
    semantically different from the non-spilled regs. In other words,
    there can be up to 64 (MAX_BPF_STACK / BPF_REG_SIZE) spilled regs
    in the stack, for example, register R<x> could have been spilled by
    the program to stack location X, Y, Z, and in mark_map_regs() we
    need to scan these stack slots of type STACK_SPILL for potential
    registers that we have to transition from PTR_TO_MAP_VALUE_OR_NULL.
    Therefore, depending on the location, the spilled_regs regno can
    be a lot higher than just MAX_BPF_REG's value since we operate on
    stack instead. The reset in mark_reg_unknown_value() itself is
    just fine, only that the BUG_ON() was inappropriate for this. Fix
    it by making a __mark_reg_unknown_value() version that can be
    called from mark_map_reg() generically; we know for the non-spilled
    case that the regno is always < MAX_BPF_REG anyway.
    
    Fixes: 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    Reported-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1889d6d9b5e767c7070ad31f93371dcb05b0cea4
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Dec 15 01:30:06 2016 +0100

    bpf: fix regression on verifier pruning wrt map lookups
    
    [ Upstream commit a08dd0da5307ba01295c8383923e51e7997c3576 ]
    
    Commit 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL
    registers") introduced a regression where existing programs stopped
    loading due to reaching the verifier's maximum complexity limit,
    whereas prior to this commit they were loading just fine; the affected
    program has roughly 2k instructions.
    
    What was found is that state pruning couldn't be performed effectively
    anymore due to mismatches of the verifier's register state, in particular
    in the id tracking. It doesn't mean that 57a09bf0a416 is incorrect per
    se, but rather that verifier needs to perform a lot more work for the
    same program with regards to involved map lookups.
    
    Since commit 57a09bf0a416 is only about tracking registers with type
    PTR_TO_MAP_VALUE_OR_NULL, the id is only needed to follow registers
    until they are promoted through pattern matching with a NULL check to
    either PTR_TO_MAP_VALUE or UNKNOWN_VALUE type. After that point, the
    id becomes irrelevant for the transitioned types.
    
    For UNKNOWN_VALUE, id is already reset to 0 via mark_reg_unknown_value(),
    but not so for PTR_TO_MAP_VALUE where id is becoming stale. It's even
    transferred further into other types that don't make use of it. Among
    others, one example is where UNKNOWN_VALUE is set on function call
    return with RET_INTEGER return type.
    
    states_equal() will then fall through the memcmp() on register state;
    note that the second memcmp() uses offsetofend(), so the id is part of
    that since d2a4dd37f6b4 ("bpf: fix state equivalence"). But the bisect
    pointed already to 57a09bf0a416, where we really reach beyond complexity
    limit. What I found was that states_equal() often failed in this
    case due to id mismatches in spilled regs with registers in type
    PTR_TO_MAP_VALUE. Unlike non-spilled regs, spilled regs just perform
    a memcmp() on their reg state and don't have any other optimizations
    in place, therefore also id was relevant in this case for making a
    pruning decision.
    
    We can safely reset id to 0 as well when converting to PTR_TO_MAP_VALUE.
    For the affected program, it resulted in a ~17 fold reduction of
    complexity and let the program load fine again. Selftest suite also
    runs fine. The only other place where env->id_gen is used currently is
    through direct packet access, but for these cases id is long living, thus
    a different scenario.
    
    Also, the current logic in mark_map_regs() is not fully correct when
    marking NULL branch with UNKNOWN_VALUE. We need to cache the destination
    reg's id in any case. Otherwise, once we marked that reg as UNKNOWN_VALUE,
    it's id is reset and any subsequent registers that hold the original id
    and are of type PTR_TO_MAP_VALUE_OR_NULL won't be marked UNKNOWN_VALUE
    anymore, since mark_map_reg() reuses the uncached regs[regno].id that
    was just overridden. Note, we don't need to cache it outside of
    mark_map_regs(), since it's called once on this_branch and the other
    time on other_branch, which are both two independent verifier states.
    A test case for this is added here, too.
    
    Fixes: 57a09bf0a416 ("bpf: Detect identical PTR_TO_MAP_VALUE_OR_NULL registers")
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 9e38375a4b1748946ab46a317def3046bb425f1e ......
	 orig commit -> 72ef9c4125c7b257e3a714d62d778ab46583d6a3 ......
checking beaa66cce55689076cacd3b6b290886d503eaa35 ......
	 orig commit -> b20e2d54789c6acbf6bd0efdbec2cf5fa4d90ef1 ......
checking 98933eb36dd25cb6797768bafb9b67af84e80a70 ......
	 orig commit -> 45caeaa5ac0b4b11784ac6f932c0ad4c6b67cda0 ......
checking 9bce26f224d87cd454ba567eb2e01a6b0252c052 ......
	 orig commit -> a13b2082ece95247779b9995c4e91b4246bed023 ......
checking 683100ed45761d56a5d2b3d79919ecdd12f8cbba ......
	 orig commit -> 79e49503efe53a8c51d8b695bedc8a346c5e4a87 ......
checking 4a8d3bb73a821e1923ba7157b3bb364e5aeab0c9 ......
	 orig commit -> 67e194007be08d071294456274dd53e0a04fdf90 ......
checking 87c0286a07f93edc874c861a9159e586fc51ee6b ......
	 orig commit -> 79099aab38c8f5c746748b066ae74ba984fe2cc8 ......
checking b61206e253020adbfde31f662ec7b5ea8b54935f ......
	 orig commit -> e37791ec1ad785b59022ae211f63a16189bacebf ......
checking 47c8dc47c0080c86c9aba36f58f6fb4a7bf84c0c ......
	 orig commit -> 52491c7607c5527138095edf44c53169dc1ddb82 ......
checking ccb65adc6ca6f1cf80cae474a4b8c8f6e6c36168 ......
	 orig commit -> 745cb7f8a5de0805cade3de3991b7a95317c7c73 ......
checking b07eed8f7119d43cbfe4d2d66241bd04099e6585 ......
	 orig commit -> 294acf1c01bace5cea5d30b510504238bf5f7c25 ......
checking db6e7796186a8d9a41e9d14b4a824c9cb80aaaf4 ......
	 orig commit -> f7887d40e541f74402df0684a1463c0a0bb68c68 ......
checking 7c0eaeec84d14d4b85773ccac8bffe8b2eafea7c ......
	 orig commit -> 62f8f4d9066c1c6f2474845d1ca7e2891f2ae3fd ......
checking 5f79aab41dedaa869ef3c706e4c0872318665884 ......
	 orig commit -> 6c4dc75c251721f517e9daeb5370ea606b5b35ce ......
checking f157cc1d7251403c950d960e3bcf988c14d9deda ......
	 orig commit -> 9ac25fc063751379cb77434fef9f3b088cd3e2f7 ......
		 9ac25fc063751379cb77434fef9f3b088cd3e2f7 has problem. Fixes commit -> 35b99dffc3f710cafceee6c8c6ac6a98eb2cb4bf
commit 58f6ebbd3424ef855cf28887f20965bfbef13b90
Author: Willem de Bruijn <willemb@google.com>
Date:   Wed Dec 13 14:41:06 2017 -0500

    sock: free skb in skb_complete_tx_timestamp on error
    
    
    [ Upstream commit 35b99dffc3f710cafceee6c8c6ac6a98eb2cb4bf ]
    
    skb_complete_tx_timestamp must ingest the skb it is passed. Call
    kfree_skb if the skb cannot be enqueued.
    
    Fixes: b245be1f4db1 ("net-timestamp: no-payload only sysctl")
    Fixes: 9ac25fc06375 ("net: fix socket refcounting in skb_complete_tx_timestamp()")
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 98fa3d2a8e399c40f681bca83f8ab522657c16db ......
	 orig commit -> dd4f10722aeb10f4f582948839f066bebe44e5fb ......
checking 07753bc6a2816c1c3b9f7bff133251f623c7bc91 ......
	 orig commit -> 02b2faaf0af1d85585f6d6980e286d53612acfc2 ......
checking 4547f03d1a624d7e92c65077b7cb5b2a33839cb3 ......
	 orig commit -> f78ef7cd9a0686b979679d0de061c6dbfd8d649e ......
checking 51ae1fbcf17325d47c20f65fb968be2d2d12fed0 ......
	 orig commit -> d5afb6f9b6bb2c57bd0c05e76e12489dc0d037d9 ......
checking 0bcc319d554cbc2414b721d773b775b3cade9bd8 ......
	 orig commit -> 48cac18ecf1de82f76259a54402c3adb7839ad01 ......
checking 3d87dce3dfd665a892d107b797e68697204c3e43 ......
	 orig commit -> 13baa00ad01bb3a9f893e3a08cbc2d072fc0c15d ......
checking 62fe0521fb6cc3b887fdc00ddca9c38d2614b8b0 ......
	 orig commit -> 540e2894f7905538740aaf122bd8e0548e1c34a4 ......
checking fa7c48fb3ad1744dab7a9a2783ae589bd87b732b ......
	 orig commit -> 8953de2f02ad7b15e4964c82f9afd60f128e4e98 ......
checking bbaeb9b73fa890dd7a6fa379a7e4822687643a4e ......
	 orig commit -> 449809a66c1d0b1563dee84493e14bf3104d2d7e ......
checking 8f4db60c7fb5120050309717123efcfd25a02034 ......
	 orig commit -> f7df4923fa986247e93ec2cdff5ca168fff14dcf ......
checking 02595f472548738cd1ab3abf424277d6f489048f ......
	 orig commit -> a717e3f740803cc88bd5c9a70c93504f6a368663 ......
checking 0a40da4a74f1767c8ff7faffe86bcb06cae280ed ......
	 orig commit -> 56de859e9967c070464a9a9f4f18d73f9447298e ......
checking feaa5bab43350b95428dc01cf1f064305e72dd87 ......
	 orig commit -> eab127717a6af54401ba534790c793ec143cd1fc ......
checking 837786cbbb60f00770b02efd15546b36008b536e ......
	 orig commit -> 51fb60eb162ab84c5edf2ae9c63cf0b878e5547e ......
checking 063893e4ec88c253ff52a8e8486169fcf5e2d840 ......
	 orig commit -> edb9d1bff4bbe19b8ae0e71b1f38732591a9eeb2 ......
checking 36931eb015ee44fe2c8f220b46500b25f7282442 ......
	 orig commit -> 6e28099d38c0e50d62c1afc054e37e573adf3d21 ......
checking a64407fafe09ca33b09aabd49c5d526b1b6b7528 ......
	 orig commit -> 1158632b5a2dcce0786c1b1b99654e81cc867981 ......
checking f7081057d12c0cb50a84869bae03fb9d406037f0 ......
	 orig commit -> 7dcdf941cdc96692ab99fd790c8cc68945514851 ......
checking ee2da79de289d062c9c3a5714b3f4d37fa6c868f ......
	 orig commit -> 4e37d6911f36545b286d15073f6f2222f840e81c ......
checking 0c6e38e791e94ae0b2a773ea7262688719072316 ......
	 orig commit -> 36154be40a28e4afaa0416da2681d80b7e2ca319 ......
checking a63326646995ffeacea6517c89cd178abb2c2af8 ......
	 orig commit -> 4078e637c12f1e0a74293f1ec9563f42bff14a03 ......
checking 9e354abf9ce35fbce434b99f0f4ab292152049af ......
	 orig commit -> 6f08a22c5fb2b9aefb8ecd8496758e7a677c1fde ......
		 6f08a22c5fb2b9aefb8ecd8496758e7a677c1fde has problem. Fixes commit -> 07c9f1e57839c678c867b89aa9dcb2220e579b13
