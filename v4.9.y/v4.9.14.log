Check from v4.9.14 to v4.9.15
Commit count: 64
checking d962bf8dd954db6db513b42cc484a9528df3e5a3 ......
checking 182ff0ebbdab926578728784299cc9d9c195d515 ......
	 orig commit -> 372b1e91343e657a7cc5e2e2bcecd5140ac28119 ......
checking 63e873679ba99649bf22cc7b964315591cedf4c5 ......
	 orig commit -> c0d0e351285161a515396b7b1ee53ec9ffd97e3c ......
checking 16ace91043bf5fa192bb6e42451524b3c6ad7bd7 ......
	 orig commit -> 40e952f9d687928b32db20226f085ae660a7237c ......
checking 1771fc58a35d6c61861c08a190ecf13cd70a38eb ......
	 orig commit -> 6ebb4a1b848fe75323135f93e72c78f8780fd268 ......
checking 2f18b39499b23579a60e8ed1d2c0b56154388323 ......
	 orig commit -> 2c4ea6e28dbf15ab93632c5c189f3948366b8885 ......
checking 91cdd9d79616ccea16e2e26fe329a15d226feb0b ......
	 orig commit -> ef947b2529f918d9606533eb9c32b187ed6a5ede ......
checking 290215a2abfd9c0ede35dfc753439ef61cfd679b ......
	 orig commit -> d24cdcd3e40a6825135498e11c20c7976b9bf545 ......
checking ff3bcdc9b5f00809a18cc1a3ea42a72e00b1a895 ......
	 orig commit -> 998d75730b40afc218c059d811869abe9676b305 ......
checking 686ea5862eb61e070881c221271f6563cb74a7f0 ......
	 orig commit -> aa9323dd49b23932a09023012f050556de64f118 ......
checking 967e17bcc96da9ab48fd621a6859d1ca55e82df9 ......
	 orig commit -> 24f76b2c87ed68f79f9f0705b11ccbefaaa0d390 ......
checking 9edc456fe621f3ba33859ea3ad3c285e544db9ad ......
	 orig commit -> f21b9a92ca7c29382909eaab9facc2cf46f2cc0b ......
checking 868a747c77cbf1d5e183dbceb912baa4db2be913 ......
	 orig commit -> ddd09373628adcbdc3f7b9098d22328834f8d772 ......
checking f72b751f434062deaf16a1aca2c5f53ddf71ed8f ......
	 orig commit -> f9ad86e42d0303eeb8e0d41bb208153022ebd9d2 ......
checking 98620b564fadc0f997194b3da0393b78b2c17447 ......
	 orig commit -> fc12bccda8b6f5c38139eceec9e369ed78091b2b ......
checking 3a654a85932fa7a909b11934df7657c1a2cb3609 ......
	 orig commit -> 85f57752b33cf12f1d583f0c10b752292de00abe ......
checking 56a567de553e0ad1440b111077dce521ecdd0cd8 ......
	 orig commit -> 31788ca803a0c89078f9e604e64286fbd9077926 ......
checking 55f47122c2e8d77a2bdb0f4bd7da57423f947824 ......
	 orig commit -> 239ac65fa5ffab71adf66e642750f940e7241d99 ......
checking ec8e40b117c3064cb826a4f25d77e45a7f87d602 ......
	 orig commit -> 36fc579761b50784b63dafd0f2e796b659e0f5ee ......
checking f96c10c2bd1ba4c438cb5e61700825f6ab376a7e ......
	 orig commit -> 3856081eede297b617560b85e948cfb00bb395ec ......
checking 5da03582e2120b04a58aabc7caa61109106e6c3d ......
	 orig commit -> 9bb92f51558f2ef5f56c257bdcea0588f31d857e ......
checking 54aa80e300d6e64d569962f25c50bc37436ae9de ......
	 orig commit -> 905f21a49d388de3e99438235f3301cabf0c0ef4 ......
checking 0734a3213ca83c92e27167624737fd7a2fcbcca5 ......
	 orig commit -> 4ce3bd45b351633f2a0512c587f7fcba2ce044e8 ......
checking b507df2e236e5edc868ea8ac572567f1de0107f7 ......
	 orig commit -> 19d19e960598161be92a7e4828eb7706c6410ce6 ......
checking 39813849996f96a764df9b993ba726e995aa1dda ......
	 orig commit -> 890030d3c425f49abaa4acf60e20f288b599f980 ......
checking 42e7f3771429d40b5307f0db0ecdba61e79272ac ......
	 orig commit -> b7540d8f25c8034de7e4163fc23ac457bf057731 ......
checking b116db0da1bd97ce405c19b304955d54f650eea9 ......
	 orig commit -> a9e9200d8661c1a0be8c39f93deb383dc940de35 ......
checking 9ad1571da2c0139db952d8df5a9e4d67a752948b ......
	 orig commit -> 86ef58a4e35e8fa66afb5898cf6dec6a3bb29f67 ......
		 86ef58a4e35e8fa66afb5898cf6dec6a3bb29f67 has problem. Fixes commit -> b03b99a329a14b7302f37c3ea6da3848db41c8c5
commit 0b914aa8cdc68c4e97ee48e5143cecd514cf1e6d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Mar 27 21:53:38 2017 -0700

    acpi, nfit, libnvdimm: fix interleave set cookie calculation (64-bit comparison)
    
    commit b03b99a329a14b7302f37c3ea6da3848db41c8c5 upstream.
    
    While reviewing the -stable patch for commit 86ef58a4e35e "nfit,
    libnvdimm: fix interleave set cookie calculation" Ben noted:
    
        "This is returning an int, thus it's effectively doing a 32-bit
         comparison and not the 64-bit comparison you say is needed."
    
    Update the compare operation to be immune to this integer demotion problem.
    
    Cc: Nicholas Moulin <nicholas.w.moulin@linux.intel.com>
    Fixes: 86ef58a4e35e ("nfit, libnvdimm: fix interleave set cookie calculation")
    Reported-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking a7b9c9ddb6f457bab2fc8527ffccf16eefba4af4 ......
	 orig commit -> 4ab18701c66552944188dbcd0ce0012729baab84 ......
checking 019c088dc403448aa29e8650c551baa1e5e29e0f ......
	 orig commit -> 8d254a340efb12b40c4c1ff25a48a4f48f7bbd6b ......
checking 1f2f16c7b7e307ce0ef1764e6142e1dd2007e40e ......
	 orig commit -> 251af29c320d86071664f02c76f0d063a19fefdf ......
checking 4f77c55c3ac232c4dfa308ce147d943b594a17ca ......
	 orig commit -> d0c424971f70501ec0a0364117b9934db039c9cc ......
checking 1afe7b4ac3df20d2b9afd90d475fa466027a6595 ......
	 orig commit -> d7d55536c6cd1f80295b6d7483ad0587b148bde4 ......
checking 17ea11d553220281ab037799642ecd45246c3a65 ......
	 orig commit -> bd4e2d2907fa23a11d46217064ecf80470ddae10 ......
checking 54eff720c99f2aeb096eb3bb98b4475bd1a0ebd9 ......
	 orig commit -> 303529d6ef1293513c2c73c9ab86489eebb37d08 ......
checking 4ee3508f7abece538c4a99c71d81e94f8df44d97 ......
	 orig commit -> 36c7c9da40c408a71e5e6bfe12e57dcf549a296d ......
checking 5da90d0018a7f9ed23698663d046146426991ffa ......
	 orig commit -> df963ea8a082d31521a120e8e31a29ad8a1dc215 ......
checking ff61e0123b7d8fe13ae8b6f96e5c3abfc11357fc ......
	 orig commit -> 32677207dcc5e594254b7fb4fb2352b1755b1d5b ......
checking 1f2ca141ec53a9c43ea0852f013907d19c435986 ......
	 orig commit -> ee194289502a6901cc77dc9a893bf2afd351ac5e ......
checking b2b0f6ffd3f97953044e909ca311d2a580ae8575 ......
	 orig commit -> 0695d7dc1d9f19b82ec2cae24856bddce278cfe6 ......
checking d3381fab77cbca6f9664cf49b3f5dd3171f1f6d3 ......
	 orig commit -> 93faccbbfa958a9668d3ab4e30f38dd205cee8d8 ......
		 93faccbbfa958a9668d3ab4e30f38dd205cee8d8 has problem. Fixes commit -> 2cbdcb882f97a45f7475c67ac6257bbc16277dfe
116ceac9741e5ab0337b0c855ba80966bfc899e2
bbc3e471011417598e598707486f5d8814ec9c01
commit 62044cba2acb26f13176434e554ef230976dbc08
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Nov 16 14:12:02 2018 +0100

    selinux: always allow mounting submounts
    
    [ Upstream commit 2cbdcb882f97a45f7475c67ac6257bbc16277dfe ]
    
    If a superblock has the MS_SUBMOUNT flag set, we should always allow
    mounting it. These mounts are done automatically by the kernel either as
    part of mounting some parent mount (e.g. debugfs always mounts tracefs
    under "tracing" for compatibility) or they are mounted automatically as
    needed on subdirectory accesses (e.g. NFS crossmnt mounts). Since such
    automounts are either an implicit consequence of the parent mount (which
    is already checked) or they can happen during regular accesses (where it
    doesn't make sense to check against the current task's context), the
    mount permission check should be skipped for them.
    
    Without this patch, attempts to access contents of an automounted
    directory can cause unexpected SELinux denials.
    
    In the current kernel tree, the MS_SUBMOUNT flag is set only via
    vfs_submount(), which is called only from the following places:
     - AFS, when automounting special "symlinks" referencing other cells
     - CIFS, when automounting "referrals"
     - NFS, when automounting subtrees
     - debugfs, when automounting tracefs
    
    In all cases the submounts are meant to be transparent to the user and
    it makes sense that if mounting the master is allowed, then so should be
    the automounts. Note that CAP_SYS_ADMIN capability checking is already
    skipped for (SB_KERNMOUNT|SB_SUBMOUNT) in:
     - sget_userns() in fs/super.c:
            if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&
                !(type->fs_flags & FS_USERNS_MOUNT) &&
                !capable(CAP_SYS_ADMIN))
                    return ERR_PTR(-EPERM);
     - sget() in fs/super.c:
            /* Ensure the requestor has permissions over the target filesystem */
            if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))
                    return ERR_PTR(-EPERM);
    
    Verified internally on patched RHEL 7.6 with a reproducer using
    NFS+httpd and selinux-tesuite.
    
    Fixes: 93faccbbfa95 ("fs: Better permission checking for submounts")
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 708f90af5f2277ddd412583b873c7fc4ce7a20ce
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 29 17:29:20 2017 -0600

    userns: Don't fail follow_automount based on s_user_ns
    
    
    [ Upstream commit bbc3e471011417598e598707486f5d8814ec9c01 ]
    
    When vfs_submount was added the test to limit automounts from
    filesystems that with s_user_ns != &init_user_ns accidentially left
    in follow_automount.  The test was never about any security concerns
    and was always about how do we implement this for filesystems whose
    s_user_ns != &init_user_ns.
    
    At the moment this check makes no difference as there are no
    filesystems that both set FS_USERNS_MOUNT and implement d_automount.
    
    Remove this check now while I am thinking about it so there will not
    be odd booby traps for someone who does want to make this combination
    work.
    
    vfs_submount still needs improvements to allow this combination to work,
    and vfs_submount contains a check that presents a warning.
    
    The autofs4 filesystem could be modified to set FS_USERNS_MOUNT and it would
    need not work on this code path, as userspace performs the mounts.
    
    Fixes: 93faccbbfa95 ("fs: Better permission checking for submounts")
    Fixes: aeaa4a79ff6a ("fs: Call d_automount with the filesystems creds")
    Acked-by:  Ian Kent <raven@themaw.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 62044cba2acb26f13176434e554ef230976dbc08
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Nov 16 14:12:02 2018 +0100

    selinux: always allow mounting submounts
    
    [ Upstream commit 2cbdcb882f97a45f7475c67ac6257bbc16277dfe ]
    
    If a superblock has the MS_SUBMOUNT flag set, we should always allow
    mounting it. These mounts are done automatically by the kernel either as
    part of mounting some parent mount (e.g. debugfs always mounts tracefs
    under "tracing" for compatibility) or they are mounted automatically as
    needed on subdirectory accesses (e.g. NFS crossmnt mounts). Since such
    automounts are either an implicit consequence of the parent mount (which
    is already checked) or they can happen during regular accesses (where it
    doesn't make sense to check against the current task's context), the
    mount permission check should be skipped for them.
    
    Without this patch, attempts to access contents of an automounted
    directory can cause unexpected SELinux denials.
    
    In the current kernel tree, the MS_SUBMOUNT flag is set only via
    vfs_submount(), which is called only from the following places:
     - AFS, when automounting special "symlinks" referencing other cells
     - CIFS, when automounting "referrals"
     - NFS, when automounting subtrees
     - debugfs, when automounting tracefs
    
    In all cases the submounts are meant to be transparent to the user and
    it makes sense that if mounting the master is allowed, then so should be
    the automounts. Note that CAP_SYS_ADMIN capability checking is already
    skipped for (SB_KERNMOUNT|SB_SUBMOUNT) in:
     - sget_userns() in fs/super.c:
            if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&
                !(type->fs_flags & FS_USERNS_MOUNT) &&
                !capable(CAP_SYS_ADMIN))
                    return ERR_PTR(-EPERM);
     - sget() in fs/super.c:
            /* Ensure the requestor has permissions over the target filesystem */
            if (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))
                    return ERR_PTR(-EPERM);
    
    Verified internally on patched RHEL 7.6 with a reproducer using
    NFS+httpd and selinux-tesuite.
    
    Fixes: 93faccbbfa95 ("fs: Better permission checking for submounts")
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
checking 48e2181b0b8d1a1e226b2932a11d6f94aef28fb8 ......
	 orig commit -> 0a6fdbdeb1c25e31763c1fb333fa2723a7d2aba6 ......
checking d5d1d2cc4be76abdabb58e1bdad84fc06090042c ......
	 orig commit -> 6cb72bc1b40bb2c1750ee7a5ebade93bed49a5fb ......
checking 516a12ab11bdd66104b1775a097a9a28c311cecb ......
	 orig commit -> d6c58dc40fec35ff6cdb350b53bce0fcf9143709 ......
checking 04f16db056d035785f217f1b958fe49ca3cd9be5 ......
	 orig commit -> 0fd27a88c2e4f548937fd7d93fc6e65c4ad7c278 ......
checking 2e539fa49efda450229e3a13db5202b4d9ae2997 ......
	 orig commit -> 2b0841766a898aba84630fb723989a77a9d3b4e6 ......
checking 1626076b8e1cde49becc0e68d2779174e6a6f599 ......
	 orig commit -> 0a0007f28304cb9fc87809c86abb80ec71317f20 ......
checking 808e83e5add13152bd4a88346487de68395c136b ......
	 orig commit -> 1064f874abc0d05eeed8993815f584d847b72486 ......
		 1064f874abc0d05eeed8993815f584d847b72486 has problem. Fixes commit -> 570487d3faf2a1d8a220e6ee10f472163123d7da
commit e260db7576765e0d82991dbe4bab2ec058ecb67a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon May 15 14:42:07 2017 -0500

    mnt: In umount propagation reparent in a separate pass
    
    commit 570487d3faf2a1d8a220e6ee10f472163123d7da upstream.
    
    It was observed that in some pathlogical cases that the current code
    does not unmount everything it should.  After investigation it
    was determined that the issue is that mnt_change_mntpoint can
    can change which mounts are available to be unmounted during mount
    propagation which is wrong.
    
    The trivial reproducer is:
    $ cat ./pathological.sh
    
    mount -t tmpfs test-base /mnt
    cd /mnt
    mkdir 1 2 1/1
    mount --bind 1 1
    mount --make-shared 1
    mount --bind 1 2
    mount --bind 1/1 1/1
    mount --bind 1/1 1/1
    echo
    grep test-base /proc/self/mountinfo
    umount 1/1
    echo
    grep test-base /proc/self/mountinfo
    
    $ unshare -Urm ./pathological.sh
    
    The expected output looks like:
    46 31 0:25 / /mnt rw,relatime - tmpfs test-base rw,uid=1000,gid=1000
    47 46 0:25 /1 /mnt/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    48 46 0:25 /1 /mnt/2 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    49 54 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    50 53 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    51 49 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    54 47 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    53 48 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    52 50 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    
    46 31 0:25 / /mnt rw,relatime - tmpfs test-base rw,uid=1000,gid=1000
    47 46 0:25 /1 /mnt/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    48 46 0:25 /1 /mnt/2 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    
    The output without the fix looks like:
    46 31 0:25 / /mnt rw,relatime - tmpfs test-base rw,uid=1000,gid=1000
    47 46 0:25 /1 /mnt/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    48 46 0:25 /1 /mnt/2 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    49 54 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    50 53 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    51 49 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    54 47 0:25 /1/1 /mnt/1/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    53 48 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    52 50 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    
    46 31 0:25 / /mnt rw,relatime - tmpfs test-base rw,uid=1000,gid=1000
    47 46 0:25 /1 /mnt/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    48 46 0:25 /1 /mnt/2 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    52 48 0:25 /1/1 /mnt/2/1 rw,relatime shared:1 - tmpfs test-base rw,uid=1000,gid=1000
    
    That last mount in the output was in the propgation tree to be unmounted but
    was missed because the mnt_change_mountpoint changed it's parent before the walk
    through the mount propagation tree observed it.
    
    Fixes: 1064f874abc0 ("mnt: Tuck mounts under others instead of creating shadow/side mounts.")
    Acked-by: Andrei Vagin <avagin@virtuozzo.com>
    Reviewed-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking c9b3f3173fa5178df2c8fe2279442f48faaf7a98 ......
	 orig commit -> 8e290cecdd0178f3d4cf7d463c51dc7e462843b4 ......
checking 53d43706f2ba5cd805093d21d69fd700584a71ab ......
	 orig commit -> 171ed0fcd8966d82c45376f1434678e7b9d4d9b1 ......
checking 411d0b0ced692dd2c0d7c10514ca8b923d8fa0f8 ......
	 orig commit -> 14a3ae34bfd0bcb1cc12d55b06a8584c11fac6fc ......
		 14a3ae34bfd0bcb1cc12d55b06a8584c11fac6fc has problem. Fixes commit -> 171ed0fcd8966d82c45376f1434678e7b9d4d9b1
commit 53d43706f2ba5cd805093d21d69fd700584a71ab
Author: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
Date:   Mon Feb 6 12:07:17 2017 +1100

    cxl: fix nested locking hang during EEH hotplug
    
    commit 171ed0fcd8966d82c45376f1434678e7b9d4d9b1 upstream.
    
    Commit 14a3ae34bfd0 ("cxl: Prevent read/write to AFU config space while AFU
    not configured") introduced a rwsem to fix an invalid memory access that
    occurred when someone attempts to access the config space of an AFU on a
    vPHB whilst the AFU is deconfigured, such as during EEH recovery.
    
    It turns out that it's possible to run into a nested locking issue when EEH
    recovery fails and a full device hotplug is required.
    cxl_pci_error_detected() deconfigures the AFU, taking a writer lock on
    configured_rwsem. When EEH recovery fails, the EEH code calls
    pci_hp_remove_devices() to remove the device, which in turn calls
    cxl_remove() -> cxl_pci_remove_afu() -> pci_deconfigure_afu(), which tries
    to grab the writer lock that's already held.
    
    Standard rwsem semantics don't express what we really want to do here and
    don't allow for nested locking. Fix this by replacing the rwsem with an
    atomic_t which we can control more finely. Allow the AFU to be locked
    multiple times so long as there are no readers.
    
    Fixes: 14a3ae34bfd0 ("cxl: Prevent read/write to AFU config space while AFU not configured")
    Signed-off-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Acked-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 60037aa689bac37816dca4eab2e8319eaa785dc6 ......
	 orig commit -> 239a3b663647869330955ec59caac0100ef9b60a ......
checking e067f68db256c2dc04aae8acb42ebfc138d87a7e ......
	 orig commit -> 4920e3cf77347d7d7373552d4839e8d832321313 ......
checking 321081d522d332b44fd506ea366e1c82cfd94d4e ......
	 orig commit -> da8fd820f389a0e29080b14c61bf5cf1d8ef5ca1 ......
checking 9d38fd6a4f6c097b32128995a260a55351dc7667 ......
	 orig commit -> fb94a687d96c570d46332a4a890f1dcb7310e643 ......
checking dc31841fcdce435ed88f87489f9ab09b48b43505 ......
	 orig commit -> 77759137248f34864a8f7a58bbcebfcf1047504a ......
checking 91cfcaa6ed46e41c8b44ee09754988b64e075ef2 ......
	 orig commit -> a4a81d8eebdc1d209d034f62a082a5131e4242b5 ......
checking b848102542f5cab63606ad4a45da2e5edc14c571 ......
	 orig commit -> a63f53e34db8b49675448d03ae324f6c5bc04fe6 ......
checking 5cec5e32ba5637076aa8f06d61f89cecd877b78e ......
	 orig commit -> 1e4a382fdc0ba8d1a85b758c0811de3a3631085e ......
checking 519b6cead21ee66ad7825750ce8aefaf64dd6792 ......
	 orig commit -> 441ad62d6c3f131f1dbd7dcdd9cbe3f74dbd8501 ......
checking 7c3bab189c16a21742172b09979fd84c13698202 ......
	 orig commit -> 96794e4ed4d758272c486e1529e431efb7045265 ......
checking 035dcc8e87f63b36f3456b39a352f0a1c785b93b ......
	 orig commit -> e1e8a9624f7ba8ead4f056ff558ed070e86fa747 ......
checking c4c590be494404531f54fa1acf580a08031f5bb9 ......
	 orig commit -> 1c9c858e2ff8ae8024a3d75d2ed080063af43754 ......
checking e5b9778761558ff3d239ed76925a1a7a734918ea ......
	 orig commit -> 82f2341c94d270421f383641b7cd670e474db56b ......
	 orig commit -> be10eb7589337e5defbe214dae038a53dd21add8 ......
