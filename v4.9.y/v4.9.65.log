Check from v4.9.65 to v4.9.66
Commit count: 139
checking 8743ce3d7c9698285310920c443c086e337aef44 ......
checking e8cee9ccac68b0ba8a14727d828b030a92a6acc6 ......
	 orig commit -> 639b08810d6ad74ded2c5f6e233c4fcb9d147168 ......
checking 82040f5c1bba893cf1a257a250962beb90d4b152 ......
	 orig commit -> 6c73f949300f17851f53fa80c9d1611ccd6909d3 ......
checking fa6e02c62a616c8442e013c0df48a01be82d15a4 ......
	 orig commit -> 7af26f889eb67db272021a939f7d4a57e96dd961 ......
checking f635fd7de9a5bbf9aaafdb8002e7a0f32cfca587 ......
	 orig commit -> a24f56d47930492c94ef6875bf45adf7607ca1a4 ......
checking 9ade62c27d3d9ac38b2dc1e496db377fd8298d92 ......
	 orig commit -> 120476123646ba3619c90db7bcbc6f8eea53c990 ......
checking 6c5bac3d6c83fbaaeeb7ca9c4ba84ac3a7ef64f1 ......
	 orig commit -> cabab3f9f5ca077535080b3252e6168935b914af ......
checking c6d800b284c56815259ab216445ec63f90b63303 ......
	 orig commit -> 1cab2a84f470e15ecc8e5143bfe9398c6e888032 ......
checking 79dec0116f8ba872f7d40530c36f3c71d2a839ec ......
	 orig commit -> 73ba39ab9307340dc98ec3622891314bbc09cc2e ......
checking bdc2571db9e7215c0557997eb763d9d4b42e9e8a ......
	 orig commit -> 8759fec4af222f338d08f8f1a7ad6a77ca6cb301 ......
checking 0e11f7efc0f68c2021e5813b30f690749f9280a4 ......
	 orig commit -> 0ea617a298dcdc2251b4e10f83ac3f3e627b66e3 ......
checking 0117c75537cfebc048afed5980246cfd123086f0 ......
	 orig commit -> 3e38df136e453aa69eb4472108ebce2fb00b1ba6 ......
checking ea13fd4cdc424dc0da2b0d717308b9f96ada098c ......
	 orig commit -> c2e756ff9e699865d294cdc112acfc36419cf5cc ......
checking 5df7cffe708f67801f01ff307b7494e02343808e ......
	 orig commit -> dadab2d4e3cf708ceba22ecddd94aedfecb39199 ......
checking ba7814bf7acba41c61b0aea39d30db4244d96937 ......
	 orig commit -> 91ca1a8c584f55857b1f6ab20a1d3a1ce7a559bb ......
checking 98dcbb9059a6e996edb02cc52286974f1ea1caff ......
	 orig commit -> db4e5376d058af8924fafd0520a0942d92538d0e ......
checking 47d1382399b8748210d640333a4d6d018f0c27b6 ......
	 orig commit -> d15697de60db5570532fdedb8e13b2251d65b8e3 ......
checking 26b6ab58999157081ea1cb7df95993a2fe1cb066 ......
	 orig commit -> 11197d006bcfabf0173a7820a163fcaac420d10e ......
checking d21e50a14c88cc93dff628550078e2204169ba85 ......
	 orig commit -> 76f43b4c0a9337af22827d78de4f2b8fd5328489 ......
		 76f43b4c0a9337af22827d78de4f2b8fd5328489 has problem. Fixes commit -> 57629915d568c522ac1422df7bba4bee5b5c7a7c
commit bf864220a59c51a676717cbee7f346a400c5ab47
Author: Ilan peer <ilan.peer@intel.com>
Date:   Mon Dec 26 18:17:36 2016 +0200

    mac80211: Fix addition of mesh configuration element
    
    commit 57629915d568c522ac1422df7bba4bee5b5c7a7c upstream.
    
    The code was setting the capabilities byte to zero,
    after it was already properly set previously. Fix it.
    
    The bug was found while debugging hwsim mesh tests failures
    that happened since the commit mentioned below.
    
    Fixes: 76f43b4c0a93 ("mac80211: Remove invalid flag operations in mesh TSF synchronization")
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Reviewed-by: Masashi Honma <masashi.honma@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Richard Sch√ºtz <rschuetz@uni-koblenz.de>
    Cc: Mathias Kretschmer <mathias.kretschmer@fit.fraunhofer.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 8068342e9f55d3b9dedfbfc1516adb0340a07f10 ......
	 orig commit -> ae9d2daecf086958a41ad216152ec208d70ba325 ......
checking 352d1060dc0e622824d74216a44097f0b59357df ......
	 orig commit -> 86c654d41a52e3d17e9bc2c2ba37f3c963e66a4a ......
checking d20e8c81d4445ead70f686e5f1195d928b24d2c3 ......
	 orig commit -> 3db93756b501e5f0a3951c79cfa9ed43c26d3455 ......
checking 86aa023fa68178d22bd90098da84165140673c7f ......
	 orig commit -> ad6d8004fa29a8958381b60215e32d1e903b0492 ......
checking d47162bdba70c4d4eccf0a728932e097f9fd9d4c ......
	 orig commit -> 972aa2c708703c21f14eb958b37e82aae2530e44 ......
checking 83e48fcd7e7ca9a7f9c8be54530b23e6628f3657 ......
	 orig commit -> 7cfe0455ee1218add152e986b89b4bb8dbeafcdd ......
checking 36b5ff248ad7ab7cfabbbe40b2c18867f2769762 ......
	 orig commit -> 486b5c22ea1d35e00e90dd79a32a9ee530b18915 ......
checking 12ad98540eee7ce3a82bdf44d95126c1078e5049 ......
	 orig commit -> 7af355e6715b325d8af29822f4c3dbecd7eeebec ......
checking 92a0b74202de21582c951f5a1f2734f4f4df2d8d ......
	 orig commit -> 097e46d2ae90265d1afe141ba6208ba598b79e01 ......
checking 628aa816ae053fe1b3539081f20fe5b1ac56f4c4 ......
	 orig commit -> d2e202c06ca42d353d95df12437740921a6d05b5 ......
		 d2e202c06ca42d353d95df12437740921a6d05b5 has problem. Fixes commit -> 7be52c03bbf7c8f53211ed13810d64dcb2bc7168
commit 16bcf48aa374e3d17d83f2b06c39a414d131a70f
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Mon Feb 13 12:38:43 2017 +0200

    ath10k: convert warning about non-existent OTP board id to debug message
    
    [ Upstream commit 7be52c03bbf7c8f53211ed13810d64dcb2bc7168 ]
    
    Currently ath10k unncessarily warns about board id not available from OTP:
    
    ath10k_pci 0000:02:00.0: pci irq msi oper_irq_mode 2 irq_mode 0 reset_mode 0
    ath10k_pci 0000:02:00.0: qca988x hw2.0 target 0x4100016c chip_id 0x043202ff sub 0000:0000
    ath10k_pci 0000:02:00.0: kconfig debug 1 debugfs 1 tracing 1 dfs 1 testmode 1
    ath10k_pci 0000:02:00.0: firmware ver 10.2.4.70.9-2 api 5 features no-p2p,raw-mode crc32 b8d50af5
    ath10k_pci 0000:02:00.0: board id is not exist in otp, ignore it
    ath10k_pci 0000:02:00.0: board_file api 1 bmi_id N/A crc32 bebc7c08
    ath10k_pci 0000:02:00.0: htt-ver 2.1 wmi-op 5 htt-op 2 cal otp max-sta 128 raw 0 hwcrypto 1
    
    But not all boards have the board id in OTP so this is not a problem and no
    need to confuse the user with that info. So this can be safely changed to a
    debug message.
    
    Also fix grammar in the debug message.
    
    Fixes: d2e202c06ca4 ("ath10k: ignore configuring the incorrect board_id")
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
checking 77bc3e95d9509546864e101341eb77870984496b ......
	 orig commit -> 88407beb1b1462f706a1950a355fd086e1c450b6 ......
checking 5553271f778df8e87b1f08979df2fc26b9fbb6a8 ......
	 orig commit -> 74c8719b8ee0922593a5cbec0bd6127d86d8a2f4 ......
checking b1d4d0e1503ecbdc1f0f612f798b93864e666657 ......
	 orig commit -> c705a6b3aa7804d7bc6660183f51e510c61dc807 ......
checking 70beeba093aa8571a8d91b96d6c2a9cc0682160e ......
	 orig commit -> a51b89698ccc93c7e274eb71377fae49c4593ab2 ......
checking 82f260d472c3b4dbb7324624e395c3e91f73a040 ......
	 orig commit -> 7357f89954b6d005df6ab8929759e78d7d9a80f9 ......
checking c46e90ba86eae229735f9a0ea2985acab03f3558 ......
	 orig commit -> 107fded7bf616ad6f46823d98b8ed6405d7adf2d ......
checking 03b497ebfdf31f54043e5d56959dbbef46c94503 ......
	 orig commit -> 6b6bbb5922a4b1d4b58125a572da91010295fba3 ......
checking 5c68a428aaafcbab570df428910caeb364efe7d2 ......
	 orig commit -> 7bb387c5ab12aeac3d5eea28686489ff46b53ca9 ......
checking d3d5e69b5e45370db9dcbc3bdde3787debcbc5bf ......
	 orig commit -> dffd0cfa06d4ed83bb3ae8eb067989ceec5d18e1 ......
checking d612bee05b031e6cac5606aff6e95ce7cd8104e4 ......
	 orig commit -> 54475f531bb8d7078f63c159e5e0615d486c498c ......
checking e7918c60da9c1d081f3f19cb46301b04e1f085c9 ......
	 orig commit -> fc318d64f3d91e15babac00e08354b1beb650b57 ......
checking 5732d69debd416c078a9570db62428995111e8d9 ......
	 orig commit -> 790d929b540661945d1c70652ffb602c5c06ad85 ......
checking 7084a27375fa31ec66b620815949134cc35121db ......
	 orig commit -> 70421257c068b91476e70cade15fca68045d0693 ......
checking ef5760f9600019dd13302263c1532706fe469c05 ......
	 orig commit -> 0f0861e31e3c59ca4bc1ec59d99260cfca79740e ......
checking b1a8a31879d6ee3f281997a1c6e08393e7d94681 ......
	 orig commit -> 977509f7c5c6fb992ffcdf4291051af343b91645 ......
checking 1d625bd43d83b400edb90b71b23ced0efdc1f2d2 ......
	 orig commit -> 3e56c2f856d7aba6a03feea834d68f9c05f7d0b6 ......
checking 5ba1957f889f575f2a240eafe543c3fda5aa72e0 ......
	 orig commit -> 584a8279a44a800dea5a5c1e9d53a002e03016b4 ......
checking aa85ae9db9d123c3d37645bbd491f9fe89b43ece ......
	 orig commit -> f9fb69adb6c7acca60977a4db5a5f95b8e66c041 ......
checking 65ce358100eaf7f7a8ab2b7dc949d562162d1f60 ......
	 orig commit -> 4aea7a5c5e940c1723add439f4088844cd26196d ......
		 4aea7a5c5e940c1723add439f4088844cd26196d has problem. Fixes commit -> 361a954e6a7215de11a6179ad9bdc07d7e394b04
745d0bd3af99ccc8c5f5822f808cd133eadad6ac
commit 265d94561cb822880e02d5057065f0840186bb7e
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Wed Jan 31 16:26:27 2018 +0900

    e1000e: Remove Other from EIAC
    
    commit 745d0bd3af99ccc8c5f5822f808cd133eadad6ac upstream.
    
    It was reported that emulated e1000e devices in vmware esxi 6.5 Build
    7526125 do not link up after commit 4aea7a5c5e94 ("e1000e: Avoid receiver
    overrun interrupt bursts", v4.15-rc1). Some tracing shows that after
    e1000e_trigger_lsc() is called, ICR reads out as 0x0 in e1000_msix_other()
    on emulated e1000e devices. In comparison, on real e1000e 82574 hardware,
    icr=0x80000004 (_INT_ASSERTED | _LSC) in the same situation.
    
    Some experimentation showed that this flaw in vmware e1000e emulation can
    be worked around by not setting Other in EIAC. This is how it was before
    16ecba59bc33 ("e1000e: Do not read ICR in Other interrupt", v4.5-rc1).
    
    Fixes: 4aea7a5c5e94 ("e1000e: Avoid receiver overrun interrupt bursts")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    [bwh: Backported to 4.9: adjust context]
    Cc: Yanhui He <yanhuih@vmware.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 22a10b606f62e9c68f91dca378da2db6b9578dd1
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Thu Feb 8 15:47:13 2018 +0900

    e1000e: Fix queue interrupt re-raising in Other interrupt
    
    commit 361a954e6a7215de11a6179ad9bdc07d7e394b04 upstream.
    
    Restores the ICS write for Rx/Tx queue interrupts which was present before
    commit 16ecba59bc33 ("e1000e: Do not read ICR in Other interrupt", v4.5-rc1)
    but was not restored in commit 4aea7a5c5e94
    ("e1000e: Avoid receiver overrun interrupt bursts", v4.15-rc1).
    
    This re-raises the queue interrupts in case the txq or rxq bits were set in
    ICR and the Other interrupt handler read and cleared ICR before the queue
    interrupt was raised.
    
    Fixes: 4aea7a5c5e94 ("e1000e: Avoid receiver overrun interrupt bursts")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Cc: Yanhui He <yanhuih@vmware.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 265d94561cb822880e02d5057065f0840186bb7e
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Wed Jan 31 16:26:27 2018 +0900

    e1000e: Remove Other from EIAC
    
    commit 745d0bd3af99ccc8c5f5822f808cd133eadad6ac upstream.
    
    It was reported that emulated e1000e devices in vmware esxi 6.5 Build
    7526125 do not link up after commit 4aea7a5c5e94 ("e1000e: Avoid receiver
    overrun interrupt bursts", v4.15-rc1). Some tracing shows that after
    e1000e_trigger_lsc() is called, ICR reads out as 0x0 in e1000_msix_other()
    on emulated e1000e devices. In comparison, on real e1000e 82574 hardware,
    icr=0x80000004 (_INT_ASSERTED | _LSC) in the same situation.
    
    Some experimentation showed that this flaw in vmware e1000e emulation can
    be worked around by not setting Other in EIAC. This is how it was before
    16ecba59bc33 ("e1000e: Do not read ICR in Other interrupt", v4.5-rc1).
    
    Fixes: 4aea7a5c5e94 ("e1000e: Avoid receiver overrun interrupt bursts")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    [bwh: Backported to 4.9: adjust context]
    Cc: Yanhui He <yanhuih@vmware.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking c0bb20ad8b54846229683af9054607414be952a6 ......
	 orig commit -> 19110cfbb34d4af0cdfe14cd243f3b09dc95b013 ......
		 19110cfbb34d4af0cdfe14cd243f3b09dc95b013 has problem. Fixes commit -> 4e7dc08e57c95673d2edaba8983c3de4dd1f65f5
4110e02eb45ea447ec6f5459c9934de0a273fb91
commit f0e0b2cc8972f05d9a17b3f37bccafd0f11df355
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Tue Mar 6 10:55:52 2018 +0900

    Revert "e1000e: Separate signaling for link check/link up"
    
    commit 3016e0a0c91246e55418825ba9aae271be267522 upstream.
    
    This reverts commit 19110cfbb34d4af0cdfe14cd243f3b09dc95b013.
    This reverts commit 4110e02eb45ea447ec6f5459c9934de0a273fb91.
    This reverts commit d3604515c9eda464a92e8e67aae82dfe07fe3c98.
    
    Commit 19110cfbb34d ("e1000e: Separate signaling for link check/link up")
    changed what happens to the link status when there is an error which
    happens after "get_link_status = false" in the copper check_for_link
    callbacks. Previously, such an error would be ignored and the link
    considered up. After that commit, any error implies that the link is down.
    
    Revert commit 19110cfbb34d ("e1000e: Separate signaling for link check/link
    up") and its followups. After reverting, the race condition described in
    the log of commit 19110cfbb34d is reintroduced. It may still be triggered
    by LSC events but this should keep the link down in case the link is
    electrically unstable, as discussed. The race may no longer be
    triggered by RXO events because commit 4aea7a5c5e94 ("e1000e: Avoid
    receiver overrun interrupt bursts") restored reading icr in the Other
    handler.
    
    Link: https://lkml.org/lkml/2018/3/1/789
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Cc: Yanhui He <yanhuih@vmware.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 36dd98b0e72da1e4ba4ab7d6b11151400fc7ae6d
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Tue Feb 20 15:12:00 2018 +0900

    e1000e: Fix check_for_link return value with autoneg off
    
    [ Upstream commit 4e7dc08e57c95673d2edaba8983c3de4dd1f65f5 ]
    
    When autoneg is off, the .check_for_link callback functions clear the
    get_link_status flag and systematically return a "pseudo-error". This means
    that the link is not detected as up until the next execution of the
    e1000_watchdog_task() 2 seconds later.
    
    Fixes: 19110cfbb34d ("e1000e: Separate signaling for link check/link up")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Acked-by: Sasha Neftin <sasha.neftin@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d598347989aa8873cebfd7d7b4d29d7aba21b878
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Mon Dec 11 16:26:40 2017 +0900

    e1000e: Fix e1000_check_for_copper_link_ich8lan return value.
    
    commit 4110e02eb45ea447ec6f5459c9934de0a273fb91 upstream.
    
    e1000e_check_for_copper_link() and e1000_check_for_copper_link_ich8lan()
    are the two functions that may be assigned to mac.ops.check_for_link when
    phy.media_type == e1000_media_type_copper. Commit 19110cfbb34d ("e1000e:
    Separate signaling for link check/link up") changed the meaning of the
    return value of check_for_link for copper media but only adjusted the first
    function. This patch adjusts the second function likewise.
    
    Reported-by: Christian Hesse <list@eworm.de>
    Reported-by: Gabriel C <nix.or.die@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198047
    Fixes: 19110cfbb34d ("e1000e: Separate signaling for link check/link up")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Tested-by: Christian Hesse <list@eworm.de>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 36dd98b0e72da1e4ba4ab7d6b11151400fc7ae6d
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Tue Feb 20 15:12:00 2018 +0900

    e1000e: Fix check_for_link return value with autoneg off
    
    [ Upstream commit 4e7dc08e57c95673d2edaba8983c3de4dd1f65f5 ]
    
    When autoneg is off, the .check_for_link callback functions clear the
    get_link_status flag and systematically return a "pseudo-error". This means
    that the link is not detected as up until the next execution of the
    e1000_watchdog_task() 2 seconds later.
    
    Fixes: 19110cfbb34d ("e1000e: Separate signaling for link check/link up")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Acked-by: Sasha Neftin <sasha.neftin@intel.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Sasha Levin <alexander.levin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d598347989aa8873cebfd7d7b4d29d7aba21b878
Author: Benjamin Poirier <bpoirier@suse.com>
Date:   Mon Dec 11 16:26:40 2017 +0900

    e1000e: Fix e1000_check_for_copper_link_ich8lan return value.
    
    commit 4110e02eb45ea447ec6f5459c9934de0a273fb91 upstream.
    
    e1000e_check_for_copper_link() and e1000_check_for_copper_link_ich8lan()
    are the two functions that may be assigned to mac.ops.check_for_link when
    phy.media_type == e1000_media_type_copper. Commit 19110cfbb34d ("e1000e:
    Separate signaling for link check/link up") changed the meaning of the
    return value of check_for_link for copper media but only adjusted the first
    function. This patch adjusts the second function likewise.
    
    Reported-by: Christian Hesse <list@eworm.de>
    Reported-by: Gabriel C <nix.or.die@gmail.com>
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198047
    Fixes: 19110cfbb34d ("e1000e: Separate signaling for link check/link up")
    Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Tested-by: Christian Hesse <list@eworm.de>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 6cfa7def5689644686530a6d28898bf21e5eb8ad ......
	 orig commit -> d3509f8bc7b0560044c15f0e3ecfde1d9af757a6 ......
checking 11fd9f91e0b6bcc8fe39868aa17163336a72a1b3 ......
	 orig commit -> c4c40e51f9c32c6dd8adf606624c930a1c4d9bbb ......
checking aa8f1adcf964a8f2ebd0c709a308d26dd4b9863b ......
	 orig commit -> 7de694782cbe7840f2c0de6f1e70f41fc1b8b6e8 ......
	 orig commit -> 8777b927b92cf5b6c29f9f9d3c737addea9ac8a7 ......
checking 2a39eae0cb5034ffe559d62cf873b6684caab0ca ......
	 orig commit -> 7978db344719dab1e56d05e6fc04aaaddcde0a5e ......
checking 8bd466c755b105d9eede2739b051890bd7018959 ......
	 orig commit -> 9523feac272ccad2ad8186ba4fcc89103754de52 ......
checking dc5f76e4e21dcb18fdf47a61eff91806308e49bd ......
	 orig commit -> a0b3bc855374c50b5ea85273553485af48caf2f7 ......
checking 1c37ff78298a6b6063649123356a312e1cce12ca ......
	 orig commit -> 4bdced5c9a2922521e325896a7bbbf0132c94e56 ......
		 4bdced5c9a2922521e325896a7bbbf0132c94e56 has problem. Fixes commit -> 364f56653708ba8bcdefd4f0da2a42904baa8eeb
ad0f1d9d65938aec72a698116cd73a980916895e
f73c52a5bcd1710994e53fbccc378c42b97a06b6
commit 1c679981309b4d36b024fc954cfcf2111a007de0
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Tue Jan 23 20:45:37 2018 -0500

    sched/rt: Use container_of() to get root domain in rto_push_irq_work_func()
    
    commit ad0f1d9d65938aec72a698116cd73a980916895e upstream.
    
    When the rto_push_irq_work_func() is called, it looks at the RT overloaded
    bitmask in the root domain via the runqueue (rq->rd). The problem is that
    during CPU up and down, nothing here stops rq->rd from changing between
    taking the rq->rd->rto_lock and releasing it. That means the lock that is
    released is not the same lock that was taken.
    
    Instead of using this_rq()->rd to get the root domain, as the irq work is
    part of the root domain, we can simply get the root domain from the irq work
    that is passed to the routine:
    
     container_of(work, struct root_domain, rto_push_work)
    
    This keeps the root domain consistent.
    
    Reported-by: Pavan Kondeti <pkondeti@codeaurora.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 4bdced5c9a292 ("sched/rt: Simplify the IPI based RT balancing logic")
    Link: http://lkml.kernel.org/r/CAEU1=PkiHO35Dzna8EQqNSKW1fr1y1zRQ5y66X117MG06sQtNA@mail.gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d266817f5028fef8ff521a77777ef1c4b8de890e
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Sat Dec 2 13:04:54 2017 -0500

    sched/rt: Do not pull from current CPU if only one CPU to pull
    
    commit f73c52a5bcd1710994e53fbccc378c42b97a06b6 upstream.
    
    Daniel Wagner reported a crash on the BeagleBone Black SoC.
    
    This is a single CPU architecture, and does not have a functional
    arch_send_call_function_single_ipi() implementation which can crash
    the kernel if that is called.
    
    As it only has one CPU, it shouldn't be called, but if the kernel is
    compiled for SMP, the push/pull RT scheduling logic now calls it for
    irq_work if the one CPU is overloaded, it can use that function to call
    itself and crash the kernel.
    
    Ideally, we should disable the SCHED_FEAT(RT_PUSH_IPI) if the system
    only has a single CPU. But SCHED_FEAT is a constant if sched debugging
    is turned off. Another fix can also be used, and this should also help
    with normal SMP machines. That is, do not initiate the pull code if
    there's only one RT overloaded CPU, and that CPU happens to be the
    current CPU that is scheduling in a lower priority task.
    
    Even on a system with many CPUs, if there's many RT tasks waiting to
    run on a single CPU, and that CPU schedules in another RT task of lower
    priority, it will initiate the PULL logic in case there's a higher
    priority RT task on another CPU that is waiting to run. But if there is
    no other CPU with waiting RT tasks, it will initiate the RT pull logic
    on itself (as it still has RT tasks waiting to run). This is a wasted
    effort.
    
    Not only does this help with SMP code where the current CPU is the only
    one with RT overloaded tasks, it should also solve the issue that
    Daniel encountered, because it will prevent the PULL logic from
    executing, as there's only one CPU on the system, and the check added
    here will cause it to exit the RT pull code.
    
    Reported-by: Daniel Wagner <wagi@monom.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-rt-users <linux-rt-users@vger.kernel.org>
    Fixes: 4bdced5c9 ("sched/rt: Simplify the IPI based RT balancing logic")
    Link: http://lkml.kernel.org/r/20171202130454.4cbbfe8d@vmware.local.home
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit a384e5437f705972d2884cea17b931c1a2cd3277
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Tue Jan 23 20:45:38 2018 -0500

    sched/rt: Up the root domain ref count when passing it around via IPIs
    
    commit 364f56653708ba8bcdefd4f0da2a42904baa8eeb upstream.
    
    When issuing an IPI RT push, where an IPI is sent to each CPU that has more
    than one RT task scheduled on it, it references the root domain's rto_mask,
    that contains all the CPUs within the root domain that has more than one RT
    task in the runable state. The problem is, after the IPIs are initiated, the
    rq->lock is released. This means that the root domain that is associated to
    the run queue could be freed while the IPIs are going around.
    
    Add a sched_get_rd() and a sched_put_rd() that will increment and decrement
    the root domain's ref count respectively. This way when initiating the IPIs,
    the scheduler will up the root domain's ref count before releasing the
    rq->lock, ensuring that the root domain does not go away until the IPI round
    is complete.
    
    Reported-by: Pavan Kondeti <pkondeti@codeaurora.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 4bdced5c9a292 ("sched/rt: Simplify the IPI based RT balancing logic")
    Link: http://lkml.kernel.org/r/CAEU1=PkiHO35Dzna8EQqNSKW1fr1y1zRQ5y66X117MG06sQtNA@mail.gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1c679981309b4d36b024fc954cfcf2111a007de0
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Tue Jan 23 20:45:37 2018 -0500

    sched/rt: Use container_of() to get root domain in rto_push_irq_work_func()
    
    commit ad0f1d9d65938aec72a698116cd73a980916895e upstream.
    
    When the rto_push_irq_work_func() is called, it looks at the RT overloaded
    bitmask in the root domain via the runqueue (rq->rd). The problem is that
    during CPU up and down, nothing here stops rq->rd from changing between
    taking the rq->rd->rto_lock and releasing it. That means the lock that is
    released is not the same lock that was taken.
    
    Instead of using this_rq()->rd to get the root domain, as the irq work is
    part of the root domain, we can simply get the root domain from the irq work
    that is passed to the routine:
    
     container_of(work, struct root_domain, rto_push_work)
    
    This keeps the root domain consistent.
    
    Reported-by: Pavan Kondeti <pkondeti@codeaurora.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: 4bdced5c9a292 ("sched/rt: Simplify the IPI based RT balancing logic")
    Link: http://lkml.kernel.org/r/CAEU1=PkiHO35Dzna8EQqNSKW1fr1y1zRQ5y66X117MG06sQtNA@mail.gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d266817f5028fef8ff521a77777ef1c4b8de890e
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Sat Dec 2 13:04:54 2017 -0500

    sched/rt: Do not pull from current CPU if only one CPU to pull
    
    commit f73c52a5bcd1710994e53fbccc378c42b97a06b6 upstream.
    
    Daniel Wagner reported a crash on the BeagleBone Black SoC.
    
    This is a single CPU architecture, and does not have a functional
    arch_send_call_function_single_ipi() implementation which can crash
    the kernel if that is called.
    
    As it only has one CPU, it shouldn't be called, but if the kernel is
    compiled for SMP, the push/pull RT scheduling logic now calls it for
    irq_work if the one CPU is overloaded, it can use that function to call
    itself and crash the kernel.
    
    Ideally, we should disable the SCHED_FEAT(RT_PUSH_IPI) if the system
    only has a single CPU. But SCHED_FEAT is a constant if sched debugging
    is turned off. Another fix can also be used, and this should also help
    with normal SMP machines. That is, do not initiate the pull code if
    there's only one RT overloaded CPU, and that CPU happens to be the
    current CPU that is scheduling in a lower priority task.
    
    Even on a system with many CPUs, if there's many RT tasks waiting to
    run on a single CPU, and that CPU schedules in another RT task of lower
    priority, it will initiate the PULL logic in case there's a higher
    priority RT task on another CPU that is waiting to run. But if there is
    no other CPU with waiting RT tasks, it will initiate the RT pull logic
    on itself (as it still has RT tasks waiting to run). This is a wasted
    effort.
    
    Not only does this help with SMP code where the current CPU is the only
    one with RT overloaded tasks, it should also solve the issue that
    Daniel encountered, because it will prevent the PULL logic from
    executing, as there's only one CPU on the system, and the check added
    here will cause it to exit the RT pull code.
    
    Reported-by: Daniel Wagner <wagi@monom.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-rt-users <linux-rt-users@vger.kernel.org>
    Fixes: 4bdced5c9 ("sched/rt: Simplify the IPI based RT balancing logic")
    Link: http://lkml.kernel.org/r/20171202130454.4cbbfe8d@vmware.local.home
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking ab49c1d0f74d19e613a5c900602c18b260782cb0 ......
	 orig commit -> 9cac9d2fb2fe0e0cadacdb94415b3fe49e3f724f ......
checking 38c043d26c97a04332df960200a389bc4141ff21 ......
	 orig commit -> 6c3b047fa2d2286d5e438bcb470c7b1a49f415f6 ......
checking bcd2dc9e329b3cf76cda88732f09aac4157fc5da ......
	 orig commit -> 3e45067f94bbd61dec0619b1c32744eb0de480c8 ......
checking c451af324cf252a5745e967c993c32a83e37f352 ......
	 orig commit -> b3120d2cc447ee77b9d69bf4ad7b452c9adb4d39 ......
checking 6d6ff7d76a24c1666a0370ea60fe12fef18d4fe2 ......
	 orig commit -> 46725b17f1c6c815a41429259b3f070c01e71bc1 ......
checking 03d1bba87a9d473364ea28f1adfa27073fedf051 ......
	 orig commit -> 05f016d2ca7a4fab99d5d5472168506ddf95e74f ......
checking 18285b20636516d5790b824f0905eadb7a83a5bb ......
	 orig commit -> 0a9a17e3bb4564caf4bfe2a6783ae1287667d188 ......
checking f1db34a454660d62726ddf5a00771daf62f8ff82 ......
	 orig commit -> 7b8edcc685b5e2c3c37aa13dc50a88e84a5bfef8 ......
checking 8f76e549e9c52366c48169f18c80c2e0557a0791 ......
	 orig commit -> f72271e2a0ae4277d53c4053f5eed8bb346ba38a ......
checking 08a3d59e7945d40d9006ef6fd6b8fa5333b08d6a ......
	 orig commit -> ae0c585d93dfaf923d2c7eb44b2c3ab92854ea9b ......
checking 9213061fb63efbf7d403d266177768afe486662d ......
	 orig commit -> 1e1f9ca546556e508d021545861f6b5fc75a95fe ......
checking 34b6b00ded9f08f06f5a4e76f01d8fcec53f1ac3 ......
	 orig commit -> c4cb99185b4cc96c0a1c70104dc21ae14d7e7f28 ......
checking e45d7db989db5722fa31541fa8b008ca00385f06 ......
	 orig commit -> 52c6912fde0133981ee50ba08808f257829c4c93 ......
checking 12d7b5042e3b5d33074e3e6d59f4a21676555270 ......
	 orig commit -> c45e3e4c5b134b081e8af362109905427967eb19 ......
checking a027c5e61dc011336fe0dea2aaceab947b519be9 ......
	 orig commit -> 8a0d18c62121d3c554a83eb96e2752861d84d937 ......
checking 8105ea3af309cea687ed46ef7cdc2de178248df3 ......
	 orig commit -> c70ca38960399a63d5c048b7b700612ea321d17e ......
checking 194eb4a4fcd2098d00bca50561a18078b2a843e0 ......
	 orig commit -> c1fb3542074fd0c4d901d778bd52455111e4eb6f ......
checking 6e83c891b68aa1f27a20489dfde38b189738bf8a ......
	 orig commit -> b18d4b8a25af6fe83d7692191d6ff962ea611c4f ......
checking 2224973f18dcbb7b2f01fc20a40e28b7faf73140 ......
	 orig commit -> 26417ae4fc6108f8db436f24108b08f68bdc520e ......
checking 8a42130ee8ae2c37f3f6ef0e3a556f907c8c82a9 ......
	 orig commit -> 33ec6dbc5a02677509d97fe36cd2105753f0f0ea ......
checking d45c593bbaeeb3aeb69d6ea5c3f353f65e213811 ......
	 orig commit -> e9d4bf219c83d09579bc62512fea2ca10f025d93 ......
checking 11ac5614d5ffce746df8f9abaadff7feb9140133 ......
	 orig commit -> 15038e14724799b8c205beb5f20f9e54896013c3 ......
checking 1be0c0ebbcbc31bab0e4bd144c5337e7b06f7467 ......
	 orig commit -> 21f2d551183847bc7fbe8d866151d00cdad18752 ......
checking 3df312771012fcefde06590294a6bcfdcc7beaf7 ......
	 orig commit -> dc3033e16c59a2c4e62b31341258a5786cbcee56 ......
checking 828064b87804bf078e92366335335219c678706a ......
	 orig commit -> 00ee9a1ca5080202bc37b44e998c3b2c74d45817 ......
checking e5386fca7e04b281e59a719a76243d83e3c2d63a ......
	 orig commit -> 4e9b6f20828ac880dbc1fa2fdbafae779473d1af ......
checking 7d159bf2afcfed2ca2557180e1166bc88f41fb06 ......
	 orig commit -> fc09785de0a364427a5df63d703bae9a306ed116 ......
checking d8dacf4545bd29d9ca6c59ddf953de194158084f ......
	 orig commit -> 1d2fcdcf33339c7c8016243de0f7f31cf6845e8d ......
checking 17074faae866ee7151f7a9dc994c72b840b3716c ......
	 orig commit -> 30863e38ebeb500a31cecee8096fb5002677dd9b ......
checking 09fd3f83d60281a2c10a47eb681cd9cc91c1804d ......
	 orig commit -> 739c64414f01748a36e7d82c8e0611dea94412bd ......
checking 8bea1b43a83cce33b84e2e4cf281bd0332c4b934 ......
	 orig commit -> 1c79df1f349fb6050016cea4ef1dfbc3853a5685 ......
checking b850daeffa105efe08a5fa4df65ff973662a33b2 ......
	 orig commit -> 3fc9fb13a4b2576aeab86c62fd64eb29ab68659c ......
checking bccfffd37b3b8c1ea2142eef8513f839e787653b ......
	 orig commit -> 8ee031631546cf2f7859cc69593bd60bbdd70b46 ......
checking 2c9ef0433c37b0db59c3b32416a75a8a54b2fbed ......
	 orig commit -> 11d49e9d089ccec81be87c2386dfdd010d7f7f6e ......
checking 193fd09bd91b62d9ad84f88830994497bd901647 ......
	 orig commit -> 2d7fe6185722b0817bb345f62ab06b76a7b26542 ......
checking af9642d85915920271256dab4bba0a70a21618f7 ......
	 orig commit -> c2432466f583cb719b35a41e757da587d9ab1d00 ......
checking 162799dbd76ec86fed4b3b2d8e87f012424407c8 ......
	 orig commit -> 3d4e8303f2c747c8540a0a0126d0151514f6468b ......
checking faa5f499825d7d802ebf96b29e6f5974fbe9ea83 ......
	 orig commit -> 0a62d6c966956d77397c32836a5bbfe3af786fc1 ......
checking 23353220b53f7b1cd700842d54d01784c58a5438 ......
	 orig commit -> f658f17b5e0e339935dca23e77e0f3cad591926b ......
checking 85cc020b46b5728e6cd4557b493ff27e4482774f ......
	 orig commit -> d937cd6790a2bef2d07b500487646bd794c039bb ......
checking 14eb4545929845f557ca8e16475c8209e1713360 ......
	 orig commit -> 20e3f985bb875fea4f86b04eba4b6cc29bfd6b71 ......
checking 9cdd4bfc42685732ac4d77650a4afac4e743b847 ......
	 orig commit -> 51e3ae81ec58e95f10a98ef3dd6d7bce5d8e35a2 ......
checking 2946ebe90ecf7f506e3e1fc49d41406bfaade551 ......
	 orig commit -> f1601113ddc0339a745e702f4fb1ca37d4875e65 ......
checking f4c97e3b4270696207528b14dee31f064e052f33 ......
	 orig commit -> 3f2a162fab15aee243178b5308bb5d1206fc4043 ......
checking a6cafd2b4b610ffb67ff96b7b94a99e8403768f0 ......
	 orig commit -> 519ce2f933fa14acf69d5c8cabcc18711943d629 ......
checking 62f0b6917eaa62ec42f88feefa690bef031e7f1f ......
	 orig commit -> 95da1b3a5aded124dd1bda1e3cdb876184813140 ......
checking 8fb42f722743c226d1079e40d4ad96d8d8aef273 ......
	 orig commit -> 3944369db701f075092357b511fd9f5755771585 ......
checking 8ead2acf0e5ade83a39dc47e97aa7ef3bc1c1ec0 ......
	 orig commit -> c05cefcc72416a37eba5a2b35f0704ed758a9145 ......
checking a896292c19e7ae9b8375d7fd24a7b5b47503543d ......
	 orig commit -> f02fee227e5f21981152850744a6084ff3fa94ee ......
checking affd159b23c4b4e6be2a574eeba963da85b74214 ......
	 orig commit -> 34be4dbf87fc3e474a842305394534216d428f5d ......
checking 770e10817e0980b61fa04f99432b1482242d65b4 ......
	 orig commit -> 91af8300d9c1d7c6b6a2fd754109e08d4798b8d8 ......
checking a1e25420a47a55784f277363ee0b76b2e2ea981d ......
	 orig commit -> b11270853fa3654f08d4a6a03b23ddb220512d8d ......
checking 7d00fdbc494306fa3a8cdaf8659ca2ab591f5830 ......
	 orig commit -> db86be3a12d0b6e5c5b51c2ab2a48f06329cb590 ......
checking 45a99f1f781adc6a3653f9f69a192607134c9693 ......
	 orig commit -> 31ccb1f7ba3cfe29631587d451cf5bb8ab593550 ......
checking ab96d9c222a9afe1b8aad723598988fe1add8065 ......
	 orig commit -> ecc0c469f27765ed1e2b967be0aa17cee1a60b76 ......
		 ecc0c469f27765ed1e2b967be0aa17cee1a60b76 has problem. Fixes commit -> 302ec300ef8a545a7fc7f667e5fd743b091c2eeb
commit d1175423ce67bd1903c4f876ba6774e3a48abdc1
Author: NeilBrown <neilb@suse.com>
Date:   Thu Dec 14 15:32:38 2017 -0800

    autofs: fix careless error in recent commit
    
    commit 302ec300ef8a545a7fc7f667e5fd743b091c2eeb upstream.
    
    Commit ecc0c469f277 ("autofs: don't fail mount for transient error") was
    meant to replace an 'if' with a 'switch', but instead added the 'switch'
    leaving the case in place.
    
    Link: http://lkml.kernel.org/r/87zi6wstmw.fsf@notabene.neil.brown.name
    Fixes: ecc0c469f277 ("autofs: don't fail mount for transient error")
    Reported-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: NeilBrown <neilb@suse.com>
    Cc: Ian Kent <raven@themaw.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking f2c97052dcb4235525fc0ef2180e3d3bc86631e0 ......
	 orig commit -> bfa62a52cad93686bb8d8171ea5288813248a7c6 ......
checking 3f6e2910c436d379788fa38c29e53ce2c40d3ae7 ......
	 orig commit -> 56a46acf62af5ba44fca2f3f1c7c25a2d5385b19 ......
checking 219f386eaea6a5abdc2d3567cf0fe5baa17cdbb7 ......
	 orig commit -> 547da673173de51f73887377eb275304775064ad ......
checking 3a63c9b9ef3d0b2c94020fe5073422e651669741 ......
	 orig commit -> 3cad14d56adbf7d621fc5a35db42f3acc0a2d6e8 ......
checking e92114860fecacadbdc9eef29b39671f675419be ......
	 orig commit -> c7fd89a6407ea3a44a2a2fa12d290162c42499c4 ......
checking 1cd9686e0a3b5b5a09a2025c21cd4d92e8db0e1f ......
	 orig commit -> b9a41d21dceadf8104812626ef85dc56ee8a60ed ......
checking 822c308a15d3d2c84b1acc874fa82eb571d4f91a ......
	 orig commit -> 8593b18ad348733b5d5ddfa0c79dcabf51dff308 ......
checking 67246fb9449a0cb060a7bcac72b5169fb4fb9f75 ......
	 orig commit -> 856eb0916d181da6d043cc33e03f54d5c5bbe54a ......
checking 6609a3cdfca457d4783b4e18fc91c462353927f4 ......
	 orig commit -> 74d4108d9e681dbbe4a2940ed8fdff1f6868184c ......
checking b0c6e0e9362fc12fbd3403d6eb51d247379f27f1 ......
	 orig commit -> 9ceace3c9c18c67676e75141032a65a8e01f9a7a ......
checking 3194d8756880e1ca443ffada537db56333e7a123 ......
	 orig commit -> 7f342678634f16795892677204366e835e450dda ......
checking 49ad11b022d6b5a9c322344dca7053590a07218d ......
	 orig commit -> 05a67cc258e75ac9758e6f13d26337b8be51162a ......
checking 351ece3a778705f4f413cc9cd221e29994fac7b3 ......
	 orig commit -> 8ef4b43cd3794d63052d85898e42424fd3b14d24 ......
checking d72cdeaf1ce80c6564543b8f9935bd3e132123c9 ......
	 orig commit -> 3b0c0c922ff4be275a8beb87ce5657d16f355b54 ......
checking eb5ede8b716ddf0d44db3e0387966b8f9ea986c0 ......
	 orig commit -> 400eeffaffc7232c0ae1134fe04e14ae4fb48d8c ......
checking e5380004ee78a6090a52a6b8deb44577ec70daa8 ......
	 orig commit -> 6218f96c58dbf44a06aeaf767aab1f54fc397838 ......
checking 0d794d0d018f23fb09c50f6ae26868bd6ae343d6 ......
	 orig commit -> ca37e57bbe0cf1455ea3e84eb89ed04a132d59e1 ......
		 ca37e57bbe0cf1455ea3e84eb89ed04a132d59e1 has problem. Fixes commit -> 5b06bbcfc2c621da3009da8decb7511500c293ed
commit 57578e52610a65386aade4db21059604537f4ed0
Author: Andy Lutomirski <luto@kernel.org>
Date:   Thu Nov 30 07:57:57 2017 -0800

    x86/power: Fix some ordering bugs in __restore_processor_context()
    
    [ Upstream commit 5b06bbcfc2c621da3009da8decb7511500c293ed ]
    
    __restore_processor_context() had a couple of ordering bugs.  It
    restored GSBASE after calling load_gs_index(), and the latter can
    call into tracing code.  It also tried to restore segment registers
    before restoring the LDT, which is straight-up wrong.
    
    Reorder the code so that we restore GSBASE, then the descriptor
    tables, then the segments.
    
    This fixes two bugs.  First, it fixes a regression that broke resume
    under certain configurations due to irqflag tracing in
    native_load_gs_index().  Second, it fixes resume when the userspace
    process that initiated suspect had funny segments.  The latter can be
    reproduced by compiling this:
    
    // SPDX-License-Identifier: GPL-2.0
    /*
     * ldt_echo.c - Echo argv[1] while using an LDT segment
     */
    
    int main(int argc, char **argv)
    {
            int ret;
            size_t len;
            char *buf;
    
            const struct user_desc desc = {
                    .entry_number    = 0,
                    .base_addr       = 0,
                    .limit           = 0xfffff,
                    .seg_32bit       = 1,
                    .contents        = 0, /* Data, grow-up */
                    .read_exec_only  = 0,
                    .limit_in_pages  = 1,
                    .seg_not_present = 0,
                    .useable         = 0
            };
    
            if (argc != 2)
                    errx(1, "Usage: %s STRING", argv[0]);
    
            len = asprintf(&buf, "%s\n", argv[1]);
            if (len < 0)
                    errx(1, "Out of memory");
    
            ret = syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));
            if (ret < -1)
                    errno = -ret;
            if (ret)
                    err(1, "modify_ldt");
    
            asm volatile ("movw %0, %%es" :: "rm" ((unsigned short)7));
            write(1, buf, len);
            return 0;
    }
    
    and running ldt_echo >/sys/power/mem
    
    Without the fix, the latter causes a triple fault on resume.
    
    Fixes: ca37e57bbe0c ("x86/entry/64: Add missing irqflags tracing to native_load_gs_index()")
    Reported-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: https://lkml.kernel.org/r/6b31721ea92f51ea839e79bd97ade4a75b1eeea2.1512057304.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
checking 2816c0455cea088f07a210f8a00701a82a78aa9c ......
	 orig commit -> 12a78d43de767eaf8fb272facb7a7b6f2dc6a9df ......
checking 443d26a6f791506ca6fdab58b355ba7e170f741e ......
	 orig commit -> 1d9ddde12e3c9bab7f3d3484eb9446315e3571ca ......
checking fb8bd56e35e18725e216b1aa2adcf8d9adc7f438 ......
	 orig commit -> 7c2102e56a3f7d85b5d8f33efbd7aecc1f36fdd8 ......
checking 6be6e48daabc18858a0a5a9d18fbd399714fc9e4 ......
	 orig commit -> 499fde662f1957e3cb8d192a94a099ebe19c714b ......
checking 41e4fbdf24c844fe6a568eb789691dc9184bee9e ......
	 orig commit -> 76da0704507bbc51875013f6557877ab308cfd0a ......
checking d0629c6bd5f6eb1438b8fc75e7ab1b2ee3a5d408 ......
	 orig commit -> cb0631fd3cf9e989cd48293fe631cbc402aec9a9 ......
checking 7003eb6399b1dcaee59d899800b4061381cde7d3 ......
	 orig commit -> 53c5eaabaea9a1b7a96f95ccc486d2ad721d95bb ......
checking 7160a4475260f7873192c27fb1a90f7564d4fb0b ......
	 orig commit -> b192571d1ae375e0bbe0aa3ccfa1a3c3704454b9 ......
		 b192571d1ae375e0bbe0aa3ccfa1a3c3704454b9 has problem. Fixes commit -> 26f4e759ef9b8a2bab1823d692ed6d56d40b66e3
checking 538099608673c08643801d2f783b4fb57a924017 ......
	 orig commit -> 5c50538752af7968f53924b22dede8ed4ce4cb3b ......
checking 550435a1d1967556856d512ee00988f717f7e3bf ......
	 orig commit -> d6e646ad7cfa7034d280459b2b2546288f247144 ......
checking c9d0db615c651ed323b955286889de1589ad4274 ......
	 orig commit -> a1c5befc1c24eb9c1ee83f711e0f21ee79cbb556 ......
