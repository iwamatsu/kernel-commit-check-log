Check from v4.9.62 to v4.9.63
Commit count: 40
checking ea88d5c5f41140cd531dab9cf718282b10996235 ......
checking e81b96cab11f57506ade92656a76db8bbe7b6673 ......
	 orig commit -> 93dc1774d2a4c7a298d5cdf78cc8acdcb7b1428d ......
checking b2dbcb7c969dcb6a2dcbe901a4a9070bb30e4788 ......
	 orig commit -> 6bcbb3174caa5f1ccc894f8ae077631659d5a629 ......
checking ff49271816665c0567d655bfeca695a9c8fb6919 ......
	 orig commit -> 59b6986dbfcdab96a971f9663221849de79a7556 ......
checking e7c9ca5a3f4674c0c531a983ae28d099156d0d54 ......
	 orig commit -> 9029679f66d976f8c720eb03c4898274803c9923 ......
checking 31c8c49428204431aee6acedbffcf97989165ae5 ......
	 orig commit -> 47b2c3fff4932e6fc17ce13d51a43c6969714e20 ......
checking a23349bb9f1283e6262c096e7b805168772dd8ca ......
	 orig commit -> e1bf1687740ce1a3598a1c5e452b852ff2190682 ......
checking 25db12f1c584263f96e07cbeec3af75be3416baa ......
	 orig commit -> 6e699867f84c0f358fed233fe6162173aca28e04 ......
checking fd1ca9fea458ca5a846aa6e5f2203e7091be6107 ......
	 orig commit -> 62b9fa2c436ffd9b87e6ed81df7f86c29fee092b ......
	 orig commit -> 8b649e426336d7d4800ff9c82858328f4215ba01 ......
checking 1862eca99e2732da2594e05406c9f78b4265bf5b ......
	 orig commit -> fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57 ......
checking 9d65d0ea55dcb813cea7df05602f233ad4843baf ......
	 orig commit -> ea04efee7635c9120d015dcdeeeb6988130cb67a ......
checking 8cf061d919e2102d0de0379bafea6cce1405d786 ......
	 orig commit -> 7c80f9e4a588f1925b07134bb2e3689335f6c6d8 ......
checking ddd95bc900ae5d2eed4fcfb3350360c87fd5b9df ......
	 orig commit -> cfbb0d90a7abb289edc91833d0905931f8805f12 ......
checking 38762a516e0cec3d194b2a9caf0607e3c7dad5ff ......
	 orig commit -> 2bdd713b92a9cade239d3c7d15205a09f556624d ......
checking 2586fa0007dc6b7745da14250be7e3aae706b128 ......
	 orig commit -> fdf7cb4185b60c68e1a75e61691c4afdc15dea0e ......
		 fdf7cb4185b60c68e1a75e61691c4afdc15dea0e has problem. Fixes commit -> cfbb0d90a7abb289edc91833d0905931f8805f12
2bdd713b92a9cade239d3c7d15205a09f556624d
commit 38762a516e0cec3d194b2a9caf0607e3c7dad5ff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 20:32:07 2017 +0200

    mac80211: use constant time comparison with keys
    
    commit 2bdd713b92a9cade239d3c7d15205a09f556624d upstream.
    
    Otherwise we risk leaking information via timing side channel.
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit ddd95bc900ae5d2eed4fcfb3350360c87fd5b9df
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Oct 24 21:12:13 2017 +0200

    mac80211: don't compare TKIP TX MIC key in reinstall prevention
    
    commit cfbb0d90a7abb289edc91833d0905931f8805f12 upstream.
    
    For the reinstall prevention, the code I had added compares the
    whole key. It turns out though that iwlwifi firmware doesn't
    provide the TKIP TX MIC key as it's not needed in client mode,
    and thus the comparison will always return false.
    
    For client mode, thus always zero out the TX MIC key part before
    doing the comparison in order to avoid accepting the reinstall
    of the key with identical encryption and RX MIC key, but not the
    same TX MIC key (since the supplicant provides the real one.)
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 38762a516e0cec3d194b2a9caf0607e3c7dad5ff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 20:32:07 2017 +0200

    mac80211: use constant time comparison with keys
    
    commit 2bdd713b92a9cade239d3c7d15205a09f556624d upstream.
    
    Otherwise we risk leaking information via timing side channel.
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking ac4cfc730e4b39d1367d636a996b965af0557bc3 ......
	 orig commit -> 6151b8b37b119e8e3a8401b080d532520c95faf4 ......
checking 7b9870f078545790f84e4de7bf31a96eb6276702 ......
	 orig commit -> 50317fce2cc70a2bbbc4b42c31bbad510382a53c ......
checking b89fc6a5caff65f5276a3e3c796710c56a6c1641 ......
	 orig commit -> d04adf1b355181e737b6b1e23d801b07f0b7c4c0 ......
		 d04adf1b355181e737b6b1e23d801b07f0b7c4c0 has problem. Fixes commit -> a8dd397903a6e57157f6265911f7d35681364427
commit 54ad2bbe34800024bebadfa9141da298af37bf86
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sun Nov 26 20:56:07 2017 +0800

    sctp: use right member as the param of list_for_each_entry
    
    [ Upstream commit a8dd397903a6e57157f6265911f7d35681364427 ]
    
    Commit d04adf1b3551 ("sctp: reset owner sk for data chunks on out queues
    when migrating a sock") made a mistake that using 'list' as the param of
    list_for_each_entry to traverse the retransmit, sacked and abandoned
    queues, while chunks are using 'transmitted_list' to link into these
    queues.
    
    It could cause NULL dereference panic if there are chunks in any of these
    queues when peeling off one asoc.
    
    So use the chunk member 'transmitted_list' instead in this patch.
    
    Fixes: d04adf1b3551 ("sctp: reset owner sk for data chunks on out queues when migrating a sock")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
checking 210a6418730b4caf082d67a7c80ecbe45ecd8f86 ......
	 orig commit -> 5c25f65fd1e42685f7ccd80e0621829c105785d9 ......
checking d6b1aebcd7a56197b3e3ececdbe3b003d03de34e ......
	 orig commit -> 8aec4959d832bae0889a8e2f348973b5e4abffef ......
checking 6d428bc40a426d0802ba09aab9e4091ccf26200e ......
	 orig commit -> f8d20b46ce55cf40afb30dcef6d9288f7ef46d9b ......
checking df0eebcea8e5af01fa4366a49179e1d72f6b8117 ......
	 orig commit -> f3594f0a7ea36661d7fd942facd7f31a64245f1a ......
checking fbf92277e6d2c9b147d010ab6d54676314630882 ......
	 orig commit -> 78e0ea6791d7baafb8a0ca82b1bd0c7b3453c919 ......
checking 62de3fe46c6b11ad3db086615dd3d46a35e7b06d ......
	 orig commit -> 0f5da659d8f1810f44de14acf2c80cd6499623a0 ......
checking 2af59c6557a5f5e18b5552fe8526033b032978d5 ......
	 orig commit -> 06f877d613be3621604c2520ec0351d9fbdca15f ......
		 06f877d613be3621604c2520ec0351d9fbdca15f has problem. Fixes commit -> 1ad98e9d1bdf4724c0a8532fabd84bf3c457c2bc
commit 4cded0a3a9c69d3c08b2ab15a7dd8206775142e4
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Oct 1 15:02:26 2018 -0700

    tcp/dccp: fix lockdep issue when SYN is backlogged
    
    [ Upstream commit 1ad98e9d1bdf4724c0a8532fabd84bf3c457c2bc ]
    
    In normal SYN processing, packets are handled without listener
    lock and in RCU protected ingress path.
    
    But syzkaller is known to be able to trick us and SYN
    packets might be processed in process context, after being
    queued into socket backlog.
    
    In commit 06f877d613be ("tcp/dccp: fix other lockdep splats
    accessing ireq_opt") I made a very stupid fix, that happened
    to work mostly because of the regular path being RCU protected.
    
    Really the thing protecting ireq->ireq_opt is RCU read lock,
    and the pseudo request refcnt is not relevant.
    
    This patch extends what I did in commit 449809a66c1d ("tcp/dccp:
    block BH for SYN processing") by adding an extra rcu_read_{lock|unlock}
    pair in the paths that might be taken when processing SYN from
    socket backlog (thus possibly in process context)
    
    Fixes: 06f877d613be ("tcp/dccp: fix other lockdep splats accessing ireq_opt")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 3107d4dc7a80b21bde703841b9db4e1d6e3976f6 ......
	 orig commit -> a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf ......
		 a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf has problem. Fixes commit -> 06f877d613be3621604c2520ec0351d9fbdca15f
commit 2af59c6557a5f5e18b5552fe8526033b032978d5
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking ec5caf5420668031e93029edb1b952e5b6dc9462 ......
	 orig commit -> b71d21c274eff20a9db8158882b545b141b73ab8 ......
checking 28fa583fd8ced11c387921e1fedc85b9c2fa506f ......
	 orig commit -> 864e2a1f8aac05effac6063ce316b480facb46ff ......
checking 3b0b4d2c47ece7d7a80e368ebe72fb84f8032aa3 ......
	 orig commit -> 1b5f962e71bfad6284574655c406597535c3ea7a ......
checking 57ffb0ecf367b584183943fbaba770c0929a89d3 ......
	 orig commit -> 509c7a1ecc8601f94ffba8a00889fefb239c00c6 ......
		 509c7a1ecc8601f94ffba8a00889fefb239c00c6 has problem. Fixes commit -> 57f015f5eccf25fd4a3336fe3cbbee920a8fba6f
checking 2ffd261337246d9a2992ca5083882790869f8986 ......
	 orig commit -> c92e8c02fe664155ac4234516e32544bec0f113d ......
		 c92e8c02fe664155ac4234516e32544bec0f113d has problem. Fixes commit -> 06f877d613be3621604c2520ec0351d9fbdca15f
a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf
commit 2af59c6557a5f5e18b5552fe8526033b032978d5
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3107d4dc7a80b21bde703841b9db4e1d6e3976f6
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Oct 22 12:33:57 2017 -0700

    tcp/dccp: fix lockdep splat in inet_csk_route_req()
    
    
    [ Upstream commit a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf ]
    
    This patch fixes the following lockdep splat in inet_csk_route_req()
    
      lockdep_rcu_suspicious
      inet_csk_route_req
      tcp_v4_send_synack
      tcp_rtx_synack
      inet_rtx_syn_ack
      tcp_fastopen_synack_time
      tcp_retransmit_timer
      tcp_write_timer_handler
      tcp_write_timer
      call_timer_fn
    
    Thread running inet_csk_route_req() owns a reference on the request
    socket, so we have the guarantee ireq->ireq_opt wont be changed or
    freed.
    
    lockdep can enforce this invariant for us.
    
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 2af59c6557a5f5e18b5552fe8526033b032978d5
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking bcb9ced1833c4cafb425077d8114d9d23de0ef95 ......
	 orig commit -> 1cc276cec9ec574d41cf47dfc0f51406b6f26ab4 ......
checking 3e2ab0ceef68ab995bc9f7c699e62b95c0edcdc4 ......
	 orig commit -> 0ad646c81b2182f7fa67ec0c8c825e0ee165696d ......
checking 9075216b8b935e467e329a5fa2e432fad96b00bf ......
	 orig commit -> 5903f594935a3841137c86b9d5b75143a5b7121c ......
checking e12c42c55287f39bfbaa2ab7e9cf04c88879768f ......
	 orig commit -> 2b7cda9c35d3b940eb9ce74b30bbd5eb30db493d ......
checking cb5880e677a1310be578b6cf4d1093d2bfa2be1a ......
	 orig commit -> c0576e3975084d4699b7bfef578613fb8e1144f6 ......
checking 4cd69ad53001ae399b6474113864a4ca190498fd ......
	 orig commit -> 41c87425a1ac9b633e0fcc78eb1f19640c8fb5a0 ......
		 41c87425a1ac9b633e0fcc78eb1f19640c8fb5a0 has problem. Fixes commit -> b87b6194be631c94785fe93398651e804ed43e28
commit e7b12efd7da92455f59f23dde01e80aaa8cdfcfa
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 21 04:41:59 2018 +0100

    netlink: put module reference if dump start fails
    
    commit b87b6194be631c94785fe93398651e804ed43e28 upstream.
    
    Before, if cb->start() failed, the module reference would never be put,
    because cb->cb_running is intentionally false at this point. Users are
    generally annoyed by this because they can no longer unload modules that
    leak references. Also, it may be possible to tediously wrap a reference
    counter back to zero, especially since module.c still uses atomic_inc
    instead of refcount_inc.
    
    This patch expands the error path to simply call module_put if
    cb->start() fails.
    
    Fixes: 41c87425a1ac ("netlink: do not set cb_running if dump's start() errs")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking d87890d9ff15458e7207369540a4f7449db493e4 ......
	 orig commit -> e669b86945478b3d90d2d87e3793a6eed06d332f ......
checking 5b9d20195a258078b0c6316fb100793ff04f2e3a ......
	 orig commit -> 93161922c658c714715686cd0cf69b090cb9bf1d ......
checking 97ba8f88b4482874d8a2ed76ab1d00bd563f7dc0 ......
	 orig commit -> 3d0241d57c7b25bb75ac9d7a62753642264fdbce ......
