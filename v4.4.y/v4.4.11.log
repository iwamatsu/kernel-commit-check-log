Check from v4.4.11 to v4.4.12
Commit count: 87
checking 351d2d4d3108a9a0f0e112dabbc36c2b1446e4f8 ......
checking e576ffd986dcd97efbd9a09361e8746d7f288946 ......
	 orig commit -> c9c6837d39311b0cc14cdbe7c18e815ab44aefb1 ......
checking 9acf5535346cb06f349ffa98ebb2408d2aa9fbca ......
	 orig commit -> 305c2e71b3d733ec065cb716c76af7d554bd5571 ......
checking 210588c0344e7daf1351aa3c68b0cd9141ab80dc ......
	 orig commit -> f05795d3d771f30a7bdc3a138bf714b06d42aa95 ......
		 f05795d3d771f30a7bdc3a138bf714b06d42aa95 has problem. Fixes commit -> f9279c968c257ee39b0d7bd2571a4d231a67bcc1
commit d896b9f298afcfc4873000a290324ba72b23eef5
Author: Ewan D. Milne <emilne@redhat.com>
Date:   Tue Jun 27 14:55:58 2017 -0400

    scsi: Add STARGET_CREATED_REMOVE state to scsi_target_state
    
    [ Upstream commit f9279c968c257ee39b0d7bd2571a4d231a67bcc1 ]
    
    The addition of the STARGET_REMOVE state had the side effect of
    introducing a race condition that can cause a crash.
    
    scsi_target_reap_ref_release() checks the starget->state to
    see if it still in STARGET_CREATED, and if so, skips calling
    transport_remove_device() and device_del(), because the starget->state
    is only set to STARGET_RUNNING after scsi_target_add() has called
    device_add() and transport_add_device().
    
    However, if an rport loss occurs while a target is being scanned,
    it can happen that scsi_remove_target() will be called while the
    starget is still in the STARGET_CREATED state.  In this case, the
    starget->state will be set to STARGET_REMOVE, and as a result,
    scsi_target_reap_ref_release() will take the wrong path.  The end
    result is a panic:
    
    [ 1255.356653] Oops: 0000 [#1] SMP
    [ 1255.360154] Modules linked in: x86_pkg_temp_thermal kvm_intel kvm irqbypass crc32c_intel ghash_clmulni_i
    [ 1255.393234] CPU: 5 PID: 149 Comm: kworker/u96:4 Tainted: G        W       4.11.0+ #8
    [ 1255.401879] Hardware name: Dell Inc. PowerEdge R320/08VT7V, BIOS 2.0.22 11/19/2013
    [ 1255.410327] Workqueue: scsi_wq_6 fc_scsi_scan_rport [scsi_transport_fc]
    [ 1255.417720] task: ffff88060ca8c8c0 task.stack: ffffc900048a8000
    [ 1255.424331] RIP: 0010:kernfs_find_ns+0x13/0xc0
    [ 1255.429287] RSP: 0018:ffffc900048abbf0 EFLAGS: 00010246
    [ 1255.435123] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
    [ 1255.443083] RDX: 0000000000000000 RSI: ffffffff8188d659 RDI: 0000000000000000
    [ 1255.451043] RBP: ffffc900048abc10 R08: 0000000000000000 R09: 0000012433fe0025
    [ 1255.459005] R10: 0000000025e5a4b5 R11: 0000000025e5a4b5 R12: ffffffff8188d659
    [ 1255.466972] R13: 0000000000000000 R14: ffff8805f55e5088 R15: 0000000000000000
    [ 1255.474931] FS:  0000000000000000(0000) GS:ffff880616b40000(0000) knlGS:0000000000000000
    [ 1255.483959] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 1255.490370] CR2: 0000000000000068 CR3: 0000000001c09000 CR4: 00000000000406e0
    [ 1255.498332] Call Trace:
    [ 1255.501058]  kernfs_find_and_get_ns+0x31/0x60
    [ 1255.505916]  sysfs_unmerge_group+0x1d/0x60
    [ 1255.510498]  dpm_sysfs_remove+0x22/0x60
    [ 1255.514783]  device_del+0xf4/0x2e0
    [ 1255.518577]  ? device_remove_file+0x19/0x20
    [ 1255.523241]  attribute_container_class_device_del+0x1a/0x20
    [ 1255.529457]  transport_remove_classdev+0x4e/0x60
    [ 1255.534607]  ? transport_add_class_device+0x40/0x40
    [ 1255.540046]  attribute_container_device_trigger+0xb0/0xc0
    [ 1255.546069]  transport_remove_device+0x15/0x20
    [ 1255.551025]  scsi_target_reap_ref_release+0x25/0x40
    [ 1255.556467]  scsi_target_reap+0x2e/0x40
    [ 1255.560744]  __scsi_scan_target+0xaa/0x5b0
    [ 1255.565312]  scsi_scan_target+0xec/0x100
    [ 1255.569689]  fc_scsi_scan_rport+0xb1/0xc0 [scsi_transport_fc]
    [ 1255.576099]  process_one_work+0x14b/0x390
    [ 1255.580569]  worker_thread+0x4b/0x390
    [ 1255.584651]  kthread+0x109/0x140
    [ 1255.588251]  ? rescuer_thread+0x330/0x330
    [ 1255.592730]  ? kthread_park+0x60/0x60
    [ 1255.596815]  ret_from_fork+0x29/0x40
    [ 1255.600801] Code: 24 08 48 83 42 40 01 5b 41 5c 5d c3 66 66 66 2e 0f 1f 84 00 00 00 00 00 66 66 66 66 90
    [ 1255.621876] RIP: kernfs_find_ns+0x13/0xc0 RSP: ffffc900048abbf0
    [ 1255.628479] CR2: 0000000000000068
    [ 1255.632756] ---[ end trace 34a69ba0477d036f ]---
    
    Fix this by adding another scsi_target state STARGET_CREATED_REMOVE
    to distinguish this case.
    
    Fixes: f05795d3d771 ("scsi: Add intermediate STARGET_REMOVE state to scsi_target_state")
    Reported-by: David Jeffery <djeffery@redhat.com>
    Signed-off-by: Ewan D. Milne <emilne@redhat.com>
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Laurence Oberman <loberman@redhat.com>
    Tested-by: Laurence Oberman <loberman@redhat.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>
checking 7e920411dd449298d76e1aef64a2ca4ef6e2655d ......
	 orig commit -> 037369b872940cd923835a0a589763180c4a36bc ......
checking 5cb3ec3d605ba80d0f33968d54bf85875d427161 ......
	 orig commit -> 44d51706b4685f965cd32acde3fe0fcc1e6198e8 ......
checking 1ba1f094568b3366c7fa8fd8e0655274badca220 ......
	 orig commit -> 1900149c835ab5b48bea31a823ea5e5a401fb560 ......
checking e044b25aa519a8a997f5669ff11e96dc2fe9ac42 ......
	 orig commit -> ca9eb49aa9562eaadf3cea071ec7018ad6800425 ......
checking b20909f10797b2fcbfed55dca4dbd131fff9a94d ......
	 orig commit -> 2ffa9a5d76a75abbc1f95c17959fced666095bdd ......
checking a03870181d89d5f02e70711139c0cbbaaa308d0d ......
	 orig commit -> 54f5c9c52d69afa55abf2b034df8d45f588466c3 ......
checking 23bc22aaa4fbcf0a244a1f024e0236dedeb12668 ......
	 orig commit -> 86c72d1ce91d804e4fa8d90b316a89597dd220f1 ......
checking b217d532e65b30ea1aaf8165809bdf457b8a6e65 ......
	 orig commit -> 7d727869c7b86da0874436ac5675dcdadaf3a0a1 ......
checking 1979d0bf95d15487f1ea4f3a50fa7e242896b35b ......
	 orig commit -> 423cd785619ac6778252fbdb916505aa1c153959 ......
checking 5058aa1ed3ed889620dc61b5427f815108916abb ......
	 orig commit -> dcd4f0db6141d6bf2cb897309d5d6f53d1b1696f ......
checking c69d01bd58505b65a5903854ac7372f84ffc8627 ......
	 orig commit -> f75564d343010b025301d9548f2304f48eb25f01 ......
checking 86dbfda83215e340445a0ae44e24c84031e79f1c ......
	 orig commit -> ec36a5c6682fdd5328abf15c3c67281bed0241d7 ......
checking 035688290a740745adf9daff65bceac8b70e8732 ......
	 orig commit -> 54cf809b9512be95f53ed4a5e3b631d1ac42f0fa ......
		 54cf809b9512be95f53ed4a5e3b631d1ac42f0fa has problem. Fixes commit -> 2c610022711675ee908b903d242f0b90e1db661f
commit a39e660a55e8ce5ae35a7694835ad464b72666ca
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Jun 8 10:19:51 2016 +0200

    locking/qspinlock: Fix spin_unlock_wait() some more
    
    commit 2c610022711675ee908b903d242f0b90e1db661f upstream.
    
    While this prior commit:
    
      54cf809b9512 ("locking,qspinlock: Fix spin_is_locked() and spin_unlock_wait()")
    
    ... fixes spin_is_locked() and spin_unlock_wait() for the usage
    in ipc/sem and netfilter, it does not in fact work right for the
    usage in task_work and futex.
    
    So while the 2 locks crossed problem:
    
            spin_lock(A)            spin_lock(B)
            if (!spin_is_locked(B)) spin_unlock_wait(A)
              foo()                 foo();
    
    ... works with the smp_mb() injected by both spin_is_locked() and
    spin_unlock_wait(), this is not sufficient for:
    
            flag = 1;
            smp_mb();               spin_lock()
            spin_unlock_wait()      if (!flag)
                                      // add to lockless list
            // iterate lockless list
    
    ... because in this scenario, the store from spin_lock() can be delayed
    past the load of flag, uncrossing the variables and loosing the
    guarantee.
    
    This patch reworks spin_is_locked() and spin_unlock_wait() to work in
    both cases by exploiting the observation that while the lock byte
    store can be delayed, the contender must have registered itself
    visibly in other state contained in the word.
    
    It also allows for architectures to override both functions, as PPC
    and ARM64 have an additional issue for which we currently have no
    generic solution.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Boqun Feng <boqun.feng@gmail.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Giovanni Gherdovich <ggherdovich@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Pan Xinhui <xinhui.pan@linux.vnet.ibm.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Waiman Long <waiman.long@hpe.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Fixes: 54cf809b9512 ("locking,qspinlock: Fix spin_is_locked() and spin_unlock_wait()")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking df8ad62006f452ee4902e216e955f1a142cf144f ......
	 orig commit -> b8995f527aac143e83d3900ff39357651ea4e0f6 ......
checking 430b4aab73830577eb22aa434b35947f87e7ea4b ......
	 orig commit -> c42850f1ae7e70056f852e67bb9dddf927853b47 ......
checking 3c5dafe43d1e36b70606d3baef8d7f24c0883343 ......
	 orig commit -> 107e15fc1f8d6ef69eac5f175971252f76e82f0d ......
checking 1401ebda89ebf3156984c175209f630e0844f6ce ......
	 orig commit -> 6f210c18c1c0f016772c8cd51ae12a02bfb9e7ef ......
checking 71378785b6bbeea4098c0dfaca0571b06297224f ......
	 orig commit -> 0f40fbbcc34e093255a2b2d70b6b0fb48c3f39aa ......
checking eb578848032f6abc2d1f78c5e5c72be5e235bffd ......
	 orig commit -> 5be605ac9af979265d7b64c160ad9928088a78be ......
checking c9715888bf1039d0009070792347a82ed665202e ......
	 orig commit -> d175feca89a1c162f60f4e3560ca7bc9437c65eb ......
checking fce893a5e3f578f9f26a2718156057c84b397f12 ......
	 orig commit -> 6798df4c5fe0a7e6d2065cf79649a794e5ba7114 ......
checking 3bf7d0328640474509d6345f9c3356e08bebf585 ......
	 orig commit -> 702f926067d2a4b28c10a3c41a1172dd62d9e735 ......
checking 039f0813ad4ed196883d87a6643041ae413dfde0 ......
	 orig commit -> 316314cae15fb0e3869b76b468f59a0c83ac3d4e ......
checking a6fa60f5614352eb53fc57b23f1984fed4e71eac ......
	 orig commit -> b45bacd2d048f405c7760e5cc9b60dd67708734f ......
checking 9e01c02f98f98c03cba7e147577364b667d03808 ......
	 orig commit -> 4355c44f063d3de4f072d796604c7f4ba4085cc3 ......
checking 4a0041b6382601e5cc2427b4a586a65361db9722 ......
	 orig commit -> f24632475d4ffed5626abbfab7ef30a128dd1474 ......
checking 1716643bc4725bb92a1f527f759a93e37a2bc1f0 ......
	 orig commit -> 9842df62004f366b9fed2423e24df10542ee0dc5 ......
checking 023bea74522670cdedcc54dea5bec1b64e3f81e3 ......
	 orig commit -> d375278d666760e195693b57415ba0a125cadd55 ......
checking 53c24ba2dd1da897950baef016f2f2d08d95cbf7 ......
	 orig commit -> 5096c4d3bfa75bdd23c78f799aabd08598afb48f ......
checking 15e67f90026240145fc9ffa84ede62ea35de2971 ......
	 orig commit -> 6fb650d43da3e7054984dc548eaa88765a94d49f ......
checking e3a037a5b851f808883b7bc6c192195635dcb758 ......
	 orig commit -> cdc77c82a8286b1181b81b6e5ef60c8e83ded7bc ......
checking 51c312792d3bb676bb1d4faa5cd0dd56d7ea2e60 ......
	 orig commit -> f78bbcae86e676fad9e6c6bb6cd9d9868ba23696 ......
checking ed97f0d96dfad18989b922c4c4095e9d06230bf6 ......
	 orig commit -> 332a5b446b7916d272c2a659a3b20909ce34d2c1 ......
checking 92f54c192b643da15504bc022dd6f17c2f930266 ......
	 orig commit -> 74d2a91aec97ab832790c9398d320413ad185321 ......
checking 9ec187e54b8630fe7235bbd66882aeb116b08d23 ......
	 orig commit -> f0d09463c59c2d764a6c6d492cbe6d2c77f27153 ......
checking 50e765292be2584a24c8e06740091d345c8be567 ......
	 orig commit -> 444f94e9e625f6ec6bbe2cb232a6451c637f35a3 ......
checking 7cb5461cf860cccf2ec36f821ee36b8baed9515b ......
	 orig commit -> c8d62957d450cc1a22ce3242908709fe367ddc8e ......
checking d6f695703c8decb0ef9740de50829961ecdcd639 ......
	 orig commit -> c5c0c55598cefc826d6cfb0a417eeaee3631715c ......
checking 68f03961991a002e6143b9d771792d42fe8a26d2 ......
	 orig commit -> 028c49f5e02a257c94129cd815f7c8485f51d4ef ......
checking 00efa6c22dd1fbbdaf1239c95ee615180512a736 ......
	 orig commit -> 35be1a71d70775e7bd7e45fa6d2897342ff4c9d2 ......
checking c0b572be507563e379a8c102b1bba57d18db26ef ......
	 orig commit -> 9e45284984096314994777f27e1446dfbfd2f0d7 ......
checking 40f9ca60c564ab71221f5b7c7da58e476cef39d5 ......
	 orig commit -> bc46b45a421a64a0895dd41a34d3d2086e1ac7f6 ......
checking 2e6440e92503f08fe016f187a6534099e16ca4e9 ......
	 orig commit -> 9d04ee11db7bf0d848266cbfd7db336097a0e239 ......
checking 2826506a7fc8a165292b109c5ad4456d60b1e580 ......
	 orig commit -> 6a8d648c8d1824117a9e9edb948ed1611fb013c0 ......
checking 2ceff6c403894da9de23a52c20bfcd81d8659a50 ......
	 orig commit -> c7c999cb18da88a881e10e07f0724ad0bfaff770 ......
checking 3295bfd3f1f39f959dba17c1637e2741f7b3c4a3 ......
	 orig commit -> 13407376b255325fa817798800117a839f3aa055 ......
checking 1af4f24cb6708615f5a0eb30f2fcfcdcc0f1766e ......
	 orig commit -> 373a32c848ae3a1c03618517cce85f9211a6facf ......
checking 7973b064f956440e419c877bf0e225df4c7dde91 ......
	 orig commit -> 822969369482166050c5b2f7013501505e025c39 ......
checking 32971328e591632a077c3683b9c36c187deadd0e ......
	 orig commit -> 32ecd320db39bcb007679ed42f283740641b81ea ......
checking 96cd084c819cdab8478942ba057b63f8bb633639 ......
	 orig commit -> ff8651237f39cea60dc89b2d9f25d9ede3fc82c0 ......
checking 419b1d21b3f498de333daf4c21c28454d444589e ......
	 orig commit -> 30c9bb0d7603e7b3f4d6a0ea231e1cddae020c32 ......
checking bb2b58c7d372e161736e2b444f9010532f9145ef ......
	 orig commit -> 265984b36ce82fec67957d452dd2b22e010611e4 ......
checking 98b0125d76fba0325acc790c2126d326f3fd0180 ......
	 orig commit -> 1c447116d017a98c90f8f71c8c5a611e0aa42178 ......
checking 24bf50bc89088686a40cb4ed7f21bd0d08ce6b0b ......
	 orig commit -> bb208f144cf3f59d8f89a09a80efd04389718907 ......
checking 9b68f12b57e5241f26c2924637aaae740cc1b276 ......
	 orig commit -> 7c9b973061b03af62734f613f6abec46c0dd4a88 ......
checking 3607d54e5aa9e72390ca9963b01e964d6425e148 ......
	 orig commit -> f86c4fbd930ff6fecf3d8a1c313182bd0f49f496 ......
checking 02c23447d5e30642ddcbaec014dedcf62f6e2d92 ......
	 orig commit -> f49cf3b8b4c841457244c461c66186a719e13bcc ......
checking c5215990d6ce401cefca648bff578a0a33667f75 ......
	 orig commit -> b49b927f16acee626c56a1af4ab4cb062f75b5df ......
checking 1df73f1884599d40c76e111e99e9511d943fa4c4 ......
	 orig commit -> 20878232c52329f92423d27a60e48b6a6389e0dd ......
checking aef531699fe1f26dd0d3e8fc9555500a517276b9 ......
	 orig commit -> 2a0974aa1a0b40a92387ea03dbfeacfbc9ba182c ......
checking a80e1fbf11b6564a9f762841b5f497c0a72720d3 ......
	 orig commit -> bdb6cf9f6fe6d9af905ea34b7c4bb78ea601329e ......
checking efc1e73ce8f21cb6b039cedced25580f2de901a5 ......
	 orig commit -> 3639ca840df953f9af6f15fc8a6bf77f19075ab1 ......
checking fd97b4fbaaf2fa1776de2cd73d9ec9d3ce82e68c ......
	 orig commit -> e930c765ca5c6b039cd22ebfb4504ea7b5dab43d ......
checking f199023137853eb1d46e8b7ebc274b29ba99028c ......
	 orig commit -> 59643d1535eb220668692a5359de22545af579f6 ......
checking dfb71aefc99d84267e5ac848d8765307ac5765f8 ......
	 orig commit -> 9b94a8fba501f38368aef6ac1b30e7335252a220 ......
checking 0e4d7a015eccd90432aeb306b8158903a35505f5 ......
	 orig commit -> cd9e2e5d3ff148be9ea210f622ce3e8e8292fcd6 ......
checking 6b83512b378928327114656589a678357c4fb88a ......
	 orig commit -> 1a967d6c9b39c226be1b45f13acd4d8a5ab3dc44 ......
checking 0e5e5bfd9be9d4835c46eb9c3a5188b61ee82240 ......
	 orig commit -> 777f69b8d26bf35ade4a76b08f203c11e048365d ......
checking 4dc809685c3b30c20f46886f54e4f96772328f3f ......
	 orig commit -> fa8f3a354bb775ec586e4475bcb07f7dece97e0c ......
checking 9ad66e1474a345fe2df897351a82640c39431f4b ......
	 orig commit -> cfda35d98298131bf38fbad3ce4cd5ecb3cf18db ......
checking b7d7ba3115bfff550958703edd4bdbd3691aea12 ......
	 orig commit -> 897fba1172d637d344f009d700f7eb8a1fa262f1 ......
checking 6ff3df201009776bd6d4316eb76078a977deb566 ......
	 orig commit -> e4fe9e7dc3828bf6a5714eb3c55aef6260d823a2 ......
checking ab85830541e8cae251ab3f87409bd13a82554374 ......
	 orig commit -> d4b9e0790aa764c0b01e18d4e8d33e93ba36d51f ......
checking 44f47d94e8424c20b8f6b38bc46514bd3428b048 ......
	 orig commit -> f228b494e56d949be8d8ea09d4f973d1979201bf ......
checking 7e1c1db08e0d4c110a253939df0bd5a0c4ddbc1f ......
	 orig commit -> 282aa7051b0169991b34716f0f22d9c2f59c46c4 ......
checking 098942bcf4b1d0573119150be8f68459d36ebde8 ......
	 orig commit -> 66dbd6e61a526ae7d11a208238ae2c17e5cacb6b ......
		 66dbd6e61a526ae7d11a208238ae2c17e5cacb6b has problem. Fixes commit -> 6d332747fa5f0a6843b56b5b129168ba909336d1
0106d456c4cb1770253fefc0ab23c9ca760b43f7
commit db769a03103b7cd1d419c76d3840e2d3a64c0df8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jul 25 14:53:03 2017 +0100

    arm64: Fix potential race with hardware DBM in ptep_set_access_flags()
    
    [ Upstream commit 6d332747fa5f0a6843b56b5b129168ba909336d1 ]
    
    In a system with DBM (dirty bit management) capable agents there is a
    possible race between a CPU executing ptep_set_access_flags() (maybe
    non-DBM capable) and a hardware update of the dirty state (clearing of
    PTE_RDONLY). The scenario:
    
    a) the pte is writable (PTE_WRITE set), clean (PTE_RDONLY set) and old
       (PTE_AF clear)
    b) ptep_set_access_flags() is called as a result of a read access and it
       needs to set the pte to writable, clean and young (PTE_AF set)
    c) a DBM-capable agent, as a result of a different write access, is
       marking the entry as young (setting PTE_AF) and dirty (clearing
       PTE_RDONLY)
    
    The current ptep_set_access_flags() implementation would set the
    PTE_RDONLY bit in the resulting value overriding the DBM update and
    losing the dirty state.
    
    This patch fixes such race by setting PTE_RDONLY to the most permissive
    (lowest value) of the current entry and the new one.
    
    Fixes: 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for hardware AF/DBM")
    Cc: Will Deacon <will.deacon@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Steve Capper <steve.capper@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e8b53a4db947494f1d808469a411f7f2f8bb3ca
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Jun 7 17:55:15 2016 +0100

    arm64: mm: always take dirty state from new pte in ptep_set_access_flags
    
    commit 0106d456c4cb1770253fefc0ab23c9ca760b43f7 upstream.
    
    Commit 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for
    hardware AF/DBM") ensured that pte flags are updated atomically in the
    face of potential concurrent, hardware-assisted updates. However, Alex
    reports that:
    
     | This patch breaks swapping for me.
     | In the broken case, you'll see either systemd cpu time spike (because
     | it's stuck in a page fault loop) or the system hang (because the
     | application owning the screen is stuck in a page fault loop).
    
    It turns out that this is because the 'dirty' argument to
    ptep_set_access_flags is always 0 for read faults, and so we can't use
    it to set PTE_RDONLY. The failing sequence is:
    
      1. We put down a PTE_WRITE | PTE_DIRTY | PTE_AF pte
      2. Memory pressure -> pte_mkold(pte) -> clear PTE_AF
      3. A read faults due to the missing access flag
      4. ptep_set_access_flags is called with dirty = 0, due to the read fault
      5. pte is then made PTE_WRITE | PTE_DIRTY | PTE_AF | PTE_RDONLY (!)
      6. A write faults, but pte_write is true so we get stuck
    
    The solution is to check the new page table entry (as would be done by
    the generic, non-atomic definition of ptep_set_access_flags that just
    calls set_pte_at) to establish the dirty state.
    
    Fixes: 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for hardware AF/DBM")
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Reported-by: Alexander Graf <agraf@suse.de>
    Tested-by: Alexander Graf <agraf@suse.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit db769a03103b7cd1d419c76d3840e2d3a64c0df8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Jul 25 14:53:03 2017 +0100

    arm64: Fix potential race with hardware DBM in ptep_set_access_flags()
    
    [ Upstream commit 6d332747fa5f0a6843b56b5b129168ba909336d1 ]
    
    In a system with DBM (dirty bit management) capable agents there is a
    possible race between a CPU executing ptep_set_access_flags() (maybe
    non-DBM capable) and a hardware update of the dirty state (clearing of
    PTE_RDONLY). The scenario:
    
    a) the pte is writable (PTE_WRITE set), clean (PTE_RDONLY set) and old
       (PTE_AF clear)
    b) ptep_set_access_flags() is called as a result of a read access and it
       needs to set the pte to writable, clean and young (PTE_AF set)
    c) a DBM-capable agent, as a result of a different write access, is
       marking the entry as young (setting PTE_AF) and dirty (clearing
       PTE_RDONLY)
    
    The current ptep_set_access_flags() implementation would set the
    PTE_RDONLY bit in the resulting value overriding the DBM update and
    losing the dirty state.
    
    This patch fixes such race by setting PTE_RDONLY to the most permissive
    (lowest value) of the current entry and the new one.
    
    Fixes: 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for hardware AF/DBM")
    Cc: Will Deacon <will.deacon@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Steve Capper <steve.capper@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 5e8b53a4db947494f1d808469a411f7f2f8bb3ca
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Jun 7 17:55:15 2016 +0100

    arm64: mm: always take dirty state from new pte in ptep_set_access_flags
    
    commit 0106d456c4cb1770253fefc0ab23c9ca760b43f7 upstream.
    
    Commit 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for
    hardware AF/DBM") ensured that pte flags are updated atomically in the
    face of potential concurrent, hardware-assisted updates. However, Alex
    reports that:
    
     | This patch breaks swapping for me.
     | In the broken case, you'll see either systemd cpu time spike (because
     | it's stuck in a page fault loop) or the system hang (because the
     | application owning the screen is stuck in a page fault loop).
    
    It turns out that this is because the 'dirty' argument to
    ptep_set_access_flags is always 0 for read faults, and so we can't use
    it to set PTE_RDONLY. The failing sequence is:
    
      1. We put down a PTE_WRITE | PTE_DIRTY | PTE_AF pte
      2. Memory pressure -> pte_mkold(pte) -> clear PTE_AF
      3. A read faults due to the missing access flag
      4. ptep_set_access_flags is called with dirty = 0, due to the read fault
      5. pte is then made PTE_WRITE | PTE_DIRTY | PTE_AF | PTE_RDONLY (!)
      6. A write faults, but pte_write is true so we get stuck
    
    The solution is to check the new page table entry (as would be done by
    the generic, non-atomic definition of ptep_set_access_flags that just
    calls set_pte_at) to establish the dirty state.
    
    Fixes: 66dbd6e61a52 ("arm64: Implement ptep_set_access_flags() for hardware AF/DBM")
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Reported-by: Alexander Graf <agraf@suse.de>
    Tested-by: Alexander Graf <agraf@suse.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 737b0679fd93f737f066ed53a86dc9ed0098d40a ......
	 orig commit -> 5bb1cc0ff9a6b68871970737e6c4c16919928d8b ......
checking f07f749170d30f6159fd29b3853380769097b37b ......
	 orig commit -> 911f56eeb87ee378f5e215469268a7a2f68a5a8a ......
checking fa5613b1f39ec020671705453eeceaaf57459e49 ......
	 orig commit -> 6ffe77bad545f4a7c8edd2a4ee797ccfcd894ab4 ......
checking eef1195bb671cd15d30df683bd0aca373943719e ......
	 orig commit -> 916d4092a1d2d7bb50630497be71ee4c4c2807fa ......
checking c5174678e2e5bd691da58a116fbc123c6fbc7b2c ......
	 orig commit -> 79c9ce57eb2d5f1497546a3946b4ae21b6fdc438 ......
checking a7a9e0efc81b7b914bc6818678af05b8d5c616be ......
	 orig commit -> ab92b232ae05c382c3df0e3d6a5c6d16b639ac8c ......
checking e1ce8c2a299d41c4c96be785c50427635e0a9c7f ......
	 orig commit -> c79b4713304f812d3d6c95826fc3e5fc2c0b0c14 ......
