Check from v4.4.73 to v4.4.74
Commit count: 33
checking 22da7ca81a3aad1af021c770b578acad86d63681 ......
checking 1f2284fac2180d7a9442c796d9755e3ce7ab0bd9 ......
	 orig commit -> f4cb767d76cf7ee72f97dd76f6cfa6c76a5edc89 ......
checking f41512c6acb71c63cf4e3bd50934365ae2a23891 ......
	 orig commit -> bd726c90b6b8ce87602208701b208a208e6d5600 ......
		 bd726c90b6b8ce87602208701b208a208e6d5600 has problem. Fixes commit -> 37511fb5c91db93d8bd6e3f52f86e5a7ff7cfcdf
commit 8f93a9aa1d654c691602359d426ab66997947b1c
Author: Helge Deller <deller@gmx.de>
Date:   Fri Jul 14 14:49:38 2017 -0700

    mm: fix overflow check in expand_upwards()
    
    commit 37511fb5c91db93d8bd6e3f52f86e5a7ff7cfcdf upstream.
    
    JÃ¶rn Engel noticed that the expand_upwards() function might not return
    -ENOMEM in case the requested address is (unsigned long)-PAGE_SIZE and
    if the architecture didn't defined TASK_SIZE as multiple of PAGE_SIZE.
    
    Affected architectures are arm, frv, m68k, blackfin, h8300 and xtensa
    which all define TASK_SIZE as 0xffffffff, but since none of those have
    an upwards-growing stack we currently have no actual issue.
    
    Nevertheless let's fix this just in case any of the architectures with
    an upward-growing stack (currently parisc, metag and partly ia64) define
    TASK_SIZE similar.
    
    Link: http://lkml.kernel.org/r/20170702192452.GA11868@p100.box
    Fixes: bd726c90b6b8 ("Allow stack to grow up to address space limit")
    Signed-off-by: Helge Deller <deller@gmx.de>
    Reported-by: Jörn Engel <joern@purestorage.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 4b359430674caa2c98d0049a6941f157d2a33741 ......
	 orig commit -> 1be7107fbe18eed3e319a6c3e83c78254b693acb ......
		 1be7107fbe18eed3e319a6c3e83c78254b693acb has problem. Fixes commit -> 561b5e0709e4a248c67d024d4d94b6e31e3edf2f
f4cb767d76cf7ee72f97dd76f6cfa6c76a5edc89
commit 1f2284fac2180d7a9442c796d9755e3ce7ab0bd9
Author: Hugh Dickins <hughd@google.com>
Date:   Tue Jun 20 02:10:44 2017 -0700

    mm: fix new crash in unmapped_area_topdown()
    
    commit f4cb767d76cf7ee72f97dd76f6cfa6c76a5edc89 upstream.
    
    Trinity gets kernel BUG at mm/mmap.c:1963! in about 3 minutes of
    mmap testing.  That's the VM_BUG_ON(gap_end < gap_start) at the
    end of unmapped_area_topdown().  Linus points out how MAP_FIXED
    (which does not have to respect our stack guard gap intentions)
    could result in gap_end below gap_start there.  Fix that, and
    the similar case in its alternative, unmapped_area().
    
    Fixes: 1be7107fbe18 ("mm: larger stack guard gap, between vmas")
    Reported-by: Dave Jones <davej@codemonkey.org.uk>
    Debugged-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 7175e56fa7076ea176ffa6dd41ddad288294ddb5
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon Jul 10 15:49:51 2017 -0700

    mm/mmap.c: do not blow on PROT_NONE MAP_FIXED holes in the stack
    
    commit 561b5e0709e4a248c67d024d4d94b6e31e3edf2f upstream.
    
    Commit 1be7107fbe18 ("mm: larger stack guard gap, between vmas") has
    introduced a regression in some rust and Java environments which are
    trying to implement their own stack guard page.  They are punching a new
    MAP_FIXED mapping inside the existing stack Vma.
    
    This will confuse expand_{downwards,upwards} into thinking that the
    stack expansion would in fact get us too close to an existing non-stack
    vma which is a correct behavior wrt safety.  It is a real regression on
    the other hand.
    
    Let's work around the problem by considering PROT_NONE mapping as a part
    of the stack.  This is a gros hack but overflowing to such a mapping
    would trap anyway an we only can hope that usespace knows what it is
    doing and handle it propely.
    
    Fixes: 1be7107fbe18 ("mm: larger stack guard gap, between vmas")
    Link: http://lkml.kernel.org/r/20170705182849.GA18027@dhcp22.suse.cz
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Debugged-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1f2284fac2180d7a9442c796d9755e3ce7ab0bd9
Author: Hugh Dickins <hughd@google.com>
Date:   Tue Jun 20 02:10:44 2017 -0700

    mm: fix new crash in unmapped_area_topdown()
    
    commit f4cb767d76cf7ee72f97dd76f6cfa6c76a5edc89 upstream.
    
    Trinity gets kernel BUG at mm/mmap.c:1963! in about 3 minutes of
    mmap testing.  That's the VM_BUG_ON(gap_end < gap_start) at the
    end of unmapped_area_topdown().  Linus points out how MAP_FIXED
    (which does not have to respect our stack guard gap intentions)
    could result in gap_end below gap_start there.  Fix that, and
    the similar case in its alternative, unmapped_area().
    
    Fixes: 1be7107fbe18 ("mm: larger stack guard gap, between vmas")
    Reported-by: Dave Jones <davej@codemonkey.org.uk>
    Debugged-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 26605a06dd921df52e2395af853367e670e6381b ......
	 orig commit -> ff86bf0c65f14346bf2440534f9ba5ac232c39a0 ......
checking c24159adf2226709053c48b3d536e756bf033e31 ......
	 orig commit -> 1a73d9310e093fc3adffba4d0a67b9fab2ee3f63 ......
checking 94695386c79caccd82bf4048da642e6c9643fb92 ......
	 orig commit -> 8ae584d1951f241efd45499f8774fd7066f22823 ......
checking aac7fa215e8fc795287328c2914aa123e7538690 ......
	 orig commit -> f4781e76f90df7aec400635d73ea4c35ee1d4765 ......
checking 4d4d501cd7079d9052bb9ea6778f15491508f95e ......
	 orig commit -> fa07ab72cbb0d843429e61bf179308aed6cbe0dd ......
checking 6af90091b61050c022c952696180c5adda217e7c ......
	 orig commit -> ef70762948dde012146926720b70e79736336764 ......
checking bfbd244c5f1889061b4a3f66519cb6dde8400877 ......
	 orig commit -> 7258ae5c5a2ce2f5969e8b18b881be40ab55433d ......
checking f5dc61753d0e27705ff79813f0f0714fd5bd37bb ......
	 orig commit -> f16443a034c7aa359ddf6f0f9bc40d01ca31faea ......
		 f16443a034c7aa359ddf6f0f9bc40d01ca31faea has problem. Fixes commit -> dec3c23c9aa1815f07d98ae0375b4cbc10971e13
7dbd8f4cabd96db5a50513de9d83a8105a5ffc81
commit e84b4a008365b7edbd842a063ae28d040a98db25
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 26 15:15:49 2017 -0400

    USB: dummy-hcd: Fix erroneous synchronization change
    
    commit 7dbd8f4cabd96db5a50513de9d83a8105a5ffc81 upstream.
    
    A recent change to the synchronization in dummy-hcd was incorrect.
    The issue was that dummy_udc_stop() contained no locking and therefore
    could race with various gadget driver callbacks, and the fix was to
    add locking and issue the callbacks with the private spinlock held.
    
    UDC drivers aren't supposed to do this.  Gadget driver callback
    routines are allowed to invoke functions in the UDC driver, and these
    functions will generally try to acquire the private spinlock.  This
    would deadlock the driver.
    
    The correct solution is to drop the spinlock before issuing callbacks,
    and avoid races by emulating the synchronize_irq() call that all real
    UDC drivers must perform in their ->udc_stop() routines after
    disabling interrupts.  This involves adding a flag to dummy-hcd's
    private structure to keep track of whether interrupts are supposed to
    be enabled, and adding a counter to keep track of ongoing callbacks so
    that dummy_udc_stop() can wait for them all to finish.
    
    A real UDC driver won't receive disconnect, reset, suspend, resume, or
    setup events once it has disabled interrupts.  dummy-hcd will receive
    them but won't try to issue any gadget driver callbacks, which should
    be just as good.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Fixes: f16443a034c7 ("USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks")
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit f409f34070299081b243aab0405b151cce28f6db
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 8 11:20:39 2018 -0400

    USB: net2280: Fix erroneous synchronization change
    
    commit dec3c23c9aa1815f07d98ae0375b4cbc10971e13 upstream.
    
    Commit f16443a034c7 ("USB: gadgetfs, dummy-hcd, net2280: fix locking
    for callbacks") was based on a serious misunderstanding.  It
    introduced regressions into both the dummy-hcd and net2280 drivers.
    
    The problem in dummy-hcd was fixed by commit 7dbd8f4cabd9 ("USB:
    dummy-hcd: Fix erroneous synchronization change"), but the problem in
    net2280 remains.  Namely: the ->disconnect(), ->suspend(), ->resume(),
    and ->reset() callbacks must be invoked without the private lock held;
    otherwise a deadlock will occur when the callback routine tries to
    interact with the UDC driver.
    
    This patch largely is a reversion of the relevant parts of
    f16443a034c7.  It also drops the private lock around the calls to
    ->suspend() and ->resume() (something the earlier patch forgot to do).
    This is safe from races with device interrupts because it occurs
    within the interrupt handler.
    
    Finally, the patch changes where the ->disconnect() callback is
    invoked when net2280_pullup() turns the pullup off.  Rather than
    making the callback from within stop_activity() at a time when dropping
    the private lock could be unsafe, the callback is moved to a point
    after the lock has already been dropped.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Fixes: f16443a034c7 ("USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks")
    Reported-by: D. Ziesche <dziesche@zes.com>
    Tested-by: D. Ziesche <dziesche@zes.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e84b4a008365b7edbd842a063ae28d040a98db25
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 26 15:15:49 2017 -0400

    USB: dummy-hcd: Fix erroneous synchronization change
    
    commit 7dbd8f4cabd96db5a50513de9d83a8105a5ffc81 upstream.
    
    A recent change to the synchronization in dummy-hcd was incorrect.
    The issue was that dummy_udc_stop() contained no locking and therefore
    could race with various gadget driver callbacks, and the fix was to
    add locking and issue the callbacks with the private spinlock held.
    
    UDC drivers aren't supposed to do this.  Gadget driver callback
    routines are allowed to invoke functions in the UDC driver, and these
    functions will generally try to acquire the private spinlock.  This
    would deadlock the driver.
    
    The correct solution is to drop the spinlock before issuing callbacks,
    and avoid races by emulating the synchronize_irq() call that all real
    UDC drivers must perform in their ->udc_stop() routines after
    disabling interrupts.  This involves adding a flag to dummy-hcd's
    private structure to keep track of whether interrupts are supposed to
    be enabled, and adding a counter to keep track of ongoing callbacks so
    that dummy_udc_stop() can wait for them all to finish.
    
    A real UDC driver won't receive disconnect, reset, suspend, resume, or
    setup events once it has disabled interrupts.  dummy-hcd will receive
    them but won't try to issue any gadget driver callbacks, which should
    be just as good.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Fixes: f16443a034c7 ("USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks")
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 89c15994a06d996f4917c3c122a4e8446a205422 ......
	 orig commit -> d2f48f05cd2a2a0a708fbfa45f1a00a87660d937 ......
checking 5efd37fe72186ef821f265dd50779ad1e2bbbec6 ......
	 orig commit -> 8128a31eaadbcdfa37774bbd28f3f00bac69996a ......
checking ab29b21a47ae9a057f66b58b06353ec459dcfb3a ......
	 orig commit -> dd14a3e9b92ac6f0918054f9e3477438760a4fa6 ......
checking 4c7a6dd205cc7e6e7e95f5d7b7b0a9a7a3fcf5e9 ......
	 orig commit -> 1f873d857b6c2fefb4dada952674aa01bcfb92bd ......
checking 42c8b4b5fdca31b47d2c55e716f651e2600690ca ......
	 orig commit -> d81182ce30dbd497a1e7047d7fda2af040347790 ......
checking dc6ecba3f6c14f493ea3be29b09415d26c8783c2 ......
	 orig commit -> 6830733d53a4517588e56227b9c8538633f0c496 ......
checking e33e866d1593281d9122fa1769ea01f4ec4e7dec ......
	 orig commit -> 1a744d2eb76aaafb997fda004ae3ae62a1538f85 ......
checking ec443ee0c2aa3c1748de683bcda3714bb4d37010 ......
	 orig commit -> 93491ced3c87c94b12220dbac0527e1356702179 ......
checking 7e2ad8b207f23a28cd3af7f0661fc1141c5a2375 ......
	 orig commit -> 6272c0de13abf1480f701d38288f28a11b4301c4 ......
checking 0c967139e8320293819277b0dddf401192b5649f ......
	 orig commit -> 784047eb2d3405a35087af70cba46170c5576b25 ......
checking e59d91144545ee6810593fdb69d2df82f61f46a6 ......
	 orig commit -> 8b8a84c54aff4256d592dc18346c65ecf6811b45 ......
checking 93d022e25642036406983d9608852c605bfd5227 ......
	 orig commit -> 861ce4a3244c21b0af64f880d5bfe5e6e2fb9e4a ......
checking c79aab7007d87c4c57b3538ac2dd2b04508fcbf8 ......
	 orig commit -> be40597a1bc173bf9dadccdf5388b956f620ae8f ......
checking daebcf9871eb2be387527e8c6cb23ad74dcb3b02 ......
	 orig commit -> f1f3e9e2a50a70de908f9dfe0d870e9cdc67e042 ......
checking bb8428f4c954ae12e8874be18826e16ba96ad1c9 ......
	 orig commit -> f181d6a3bcc35633facf5f3925699021c13492c5 ......
checking 5f1f39023c2a439204d47e7e33d94b5baf561ca8 ......
	 orig commit -> 98c67d187db7808b1f3c95f2110dd4392d034182 ......
checking 156f00663af610f740e22d494d8ff855f12cd8a5 ......
	 orig commit -> 769dc04db3ed8484798aceb015b94deacc2ba557 ......
checking a8686c968fe3dd25b6f1f88d88de00c95545c931 ......
	 orig commit -> 5ebb6dd36c9f5fb37b1077b393c254d70a14cb46 ......
checking fa90f02d511dcc85f77c110cb0c6f3555e885863 ......
	 orig commit -> b8e11f7d2791bd9320be1c6e772a60b2aa093e45 ......
checking 58ab7a86cdc29de64cea665fa97f02829756b554 ......
	 orig commit -> 5cda3ee5138e91ac369ed9d0b55eab0dab077686 ......
checking 0ad134d81c070a391783f84d7ab9dd13ad6ef7e9 ......
	 orig commit -> ba80aa909c99802c428682c352b0ee0baac0acd3 ......
