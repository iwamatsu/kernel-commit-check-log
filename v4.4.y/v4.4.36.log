Check from v4.4.36 to v4.4.37
Commit count: 14
checking e5f84c1444ae59c85bd25ba05393c6bc87067ddb ......
checking 71710cd35a554b1f0a60f035642455beeaec0f06 ......
	 orig commit -> d08544127d9fb4505635e3cb6871fd50a42947bd ......
checking d24207a0d81cee81d0f06397074db99e12cc87c1 ......
	 orig commit -> 7209c868600bd8926e37c10b9aae83124ccc1dd8 ......
checking da643dc17f20e04c089c93a3fe7d89e5be80d1af ......
	 orig commit -> 2a6dcb2b5f3e21592ca8dfa198dcce7bec09b020 ......
checking 4fd108fa1a7438566e2b16bee74228c3227c9597 ......
	 orig commit -> 0e1614ac84f1719d87bed577963bb8140d0c9ce8 ......
checking d7a2c259fc1f41c3c030868b0344112c92f06c34 ......
	 orig commit -> fcd2042e8d36cf644bd2d69c26378d17158b17df ......
checking ac6e42d7a7201245e9a8db922ad795ef2a257568 ......
	 orig commit -> e42010d8207f9d15a605ceb8e321bcd9648071b0 ......
checking 140ff0a348970430e4eb06a63afbbe5510f9c8d1 ......
	 orig commit -> e784930bd645e7df78c66e7872fec282b0620075 ......
checking dfb704f96cd190239e7b86b09810a136cf25506e ......
	 orig commit -> bedc1969150d480c462cdac320fa944b694a7162 ......
checking 58cebd1a08ed114e05cc9d16dee9e5423f564c82 ......
	 orig commit -> 3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4 ......
checking 5a5f7030194da0c47201c04b4831f1ca623779a9 ......
	 orig commit -> fc0e81b2bea0ebceb71889b61d2240856141c9ee ......
checking 995761627d97cc374f14203589b3a6385019bf0b ......
	 orig commit -> 045d599a286bc01daa3510d59272440a17b23c2e ......
checking 61ab6247366349aca80330db1c708c798b1c9774 ......
	 orig commit -> 529e71e16403830ae0d737a66c55c5f360f3576b ......
checking 5b2ed6e5382a313b0856ba676595ba35067219bc ......
	 orig commit -> 3c7c7a2fc8811bc7097479f69acf2527693d7562 ......
		 3c7c7a2fc8811bc7097479f69acf2527693d7562 has problem. Fixes commit -> 36425cd67052e3becf325fd4d3ba5691791ef7e4
commit 42ad7663677d886b6bd95f64c881cafdff24399a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jan 24 10:23:42 2017 -0800

    ARC: udelay: fix inline assembler by adding LP_COUNT to clobber list
    
    commit 36425cd67052e3becf325fd4d3ba5691791ef7e4 upstream.
    
    commit 3c7c7a2fc8811bc ("ARC: Don't use "+l" inline asm constraint")
    modified the inline assembly to setup LP_COUNT register manually and NOT
    rely on gcc to do it (with the +l inline assembler contraint hint, now
    being retired in the compiler)
    
    However the fix was flawed as we didn't add LP_COUNT to asm clobber list,
    meaning gcc doesn't know that LP_COUNT or zero-delay-loops are in action
    in the inline asm.
    
    This resulted in some fun - as nested ZOL loops were being generared
    
    | mov lp_count,250000 ;16 # tmp235,
    | lp .L__GCC__LP14 #            <======= OUTER LOOP (gcc generated)
    |   .L14:
    |   ld r2, [r5] # MEM[(volatile u32 *)prephitmp_43], w
    |   dmb 1
    |   breq r2, -1, @.L21 #, w,,
    |   bbit0 r2,1,@.L13 # w,,
    |   ld r4,[r7] ;25 # loops_per_jiffy, loops_per_jiffy
    |   mpymu r3,r4,r6 #, loops_per_jiffy, tmp234
    |
    |   mov lp_count, r3 #           <====== INNER LOOP (from inline asm)
    |   lp 1f
    |        nop
    |   1:
    |   nop_s
    | .L__GCC__LP14: ; loop end, start is @.L14 #,
    
    This caused issues with drivers relying on sane behaviour of udelay
    friends.
    
    With LP_COUNT added to clobber list, gcc doesn't generate the outer
    loop in say above case.
    
    Addresses STAR 9001146134
    
    Reported-by: Joao Pinto <jpinto@synopsys.com>
    Fixes: 3c7c7a2fc8811bc ("ARC: Don't use "+l" inline asm constraint")
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
