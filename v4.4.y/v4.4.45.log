Check from v4.4.45 to v4.4.46
Commit count: 24
checking 6c1ed78cb07494c721e9849c92987d029a2e816f ......
checking d0721893214ef0bee75ef45e17ce03870eb83c94 ......
	 orig commit -> 3674534b775354516e5c148ea48f51d4d1909a78 ......
checking 14b97492d6e1a8b631f3bf917fd3648f129f8c12 ......
	 orig commit -> 5a00b6c2438460b870a451f14593fc40d3c7edf6 ......
checking d430c37db796cc0fa8882acf094c9f06828d9a40 ......
	 orig commit -> ecc8995363ee6231b32dad61c955b371b79cc4cf ......
checking 5ddaf6804e24e22fe803ad2df9499c28fad21d9d ......
	 orig commit -> c739c0a7c3c2472d7562b8f802cdce44d2597c8b ......
checking 5288474d2f48f5b7bf4c87871c8081b3f11c52f7 ......
	 orig commit -> 828f6fa65ce7e80f77f5ab12942e44eb3d9d174e ......
checking e114e66eec3d447cd1f5b5637e30c42424313eaf ......
	 orig commit -> fc791b6335152c5278dc4a4991bcb2d329f806f9 ......
		 fc791b6335152c5278dc4a4991bcb2d329f806f9 has problem. Fixes commit -> 19cdead3e2ef8ed765c5d1ce48057ca9d97b5094
2b0841766a898aba84630fb723989a77a9d3b4e6
commit b1f4be0ee470f7244d85152dbde7f50a23d15c0b
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Thu Apr 27 19:29:34 2017 +0200

    bonding: avoid defaulting hard_header_len to ETH_HLEN on slave removal
    
    [ Upstream commit 19cdead3e2ef8ed765c5d1ce48057ca9d97b5094 ]
    
    On slave list updates, the bonding driver computes its hard_header_len
    as the maximum of all enslaved devices's hard_header_len.
    If the slave list is empty, e.g. on last enslaved device removal,
    ETH_HLEN is used.
    
    Since the bonding header_ops are set only when the first enslaved
    device is attached, the above can lead to header_ops->create()
    being called with the wrong skb headroom in place.
    
    If bond0 is configured on top of ipoib devices, with the
    following commands:
    
    ifup bond0
    for slave in $BOND_SLAVES_LIST; do
            ip link set dev $slave nomaster
    done
    ping -c 1 <ip on bond0 subnet>
    
    we will obtain a skb_under_panic() with a similar call trace:
            skb_push+0x3d/0x40
            push_pseudo_header+0x17/0x30 [ib_ipoib]
            ipoib_hard_header+0x4e/0x80 [ib_ipoib]
            arp_create+0x12f/0x220
            arp_send_dst.part.19+0x28/0x50
            arp_solicit+0x115/0x290
            neigh_probe+0x4d/0x70
            __neigh_event_send+0xa7/0x230
            neigh_resolve_output+0x12e/0x1c0
            ip_finish_output2+0x14b/0x390
            ip_finish_output+0x136/0x1e0
            ip_output+0x76/0xe0
            ip_local_out+0x35/0x40
            ip_send_skb+0x19/0x40
            ip_push_pending_frames+0x33/0x40
            raw_sendmsg+0x7d3/0xb50
            inet_sendmsg+0x31/0xb0
            sock_sendmsg+0x38/0x50
            SYSC_sendto+0x102/0x190
            SyS_sendto+0xe/0x10
            do_syscall_64+0x67/0x180
            entry_SYSCALL64_slow_path+0x25/0x25
    
    This change addresses the issue avoiding updating the bonding device
    hard_header_len when the slaves list become empty, forbidding to
    shrink it below the value used by header_ops->create().
    
    The bug is there since commit 54ef31371407 ("[PATCH] bonding: Handle large
    hard_header_len") but the panic can be triggered only since
    commit fc791b633515 ("IB/ipoib: move back IB LL address into the hard
    header").
    
    Reported-by: Norbert P <noe@physik.uzh.ch>
    Fixes: 54ef31371407 ("[PATCH] bonding: Handle large hard_header_len")
    Fixes: fc791b633515 ("IB/ipoib: move back IB LL address into the hard header")
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bb4a21dcb6fb57892eea7c941fdfd57e55ba5dbe
Author: Erez Shitrit <erezsh@mellanox.com>
Date:   Wed Feb 1 19:10:05 2017 +0200

    IB/IPoIB: Add destination address when re-queue packet
    
    commit 2b0841766a898aba84630fb723989a77a9d3b4e6 upstream.
    
    When sending packet to destination that was not resolved yet
    via path query, the driver keeps the skb and tries to re-send it
    again when the path is resolved.
    
    But when re-sending via dev_queue_xmit the kernel doesn't call
    to dev_hard_header, so IPoIB needs to keep 20 bytes in the skb
    and to put the destination address inside them.
    
    In that way the dev_start_xmit will have the correct destination,
    and the driver won't take the destination from the skb->data, while
    nothing exists there, which causes to packet be be dropped.
    
    The test flow is:
    1. Run the SM on remote node,
    2. Restart the driver.
    4. Ping some destination,
    3. Observe that first ICMP request will be dropped.
    
    Fixes: fc791b633515 ("IB/ipoib: move back IB LL address into the hard header")
    Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
    Signed-off-by: Noa Osherovich <noaos@mellanox.com>
    Signed-off-by: Leon Romanovsky <leon@kernel.org>
    Tested-by: Yuval Shaia <yuval.shaia@oracle.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit b1f4be0ee470f7244d85152dbde7f50a23d15c0b
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Thu Apr 27 19:29:34 2017 +0200

    bonding: avoid defaulting hard_header_len to ETH_HLEN on slave removal
    
    [ Upstream commit 19cdead3e2ef8ed765c5d1ce48057ca9d97b5094 ]
    
    On slave list updates, the bonding driver computes its hard_header_len
    as the maximum of all enslaved devices's hard_header_len.
    If the slave list is empty, e.g. on last enslaved device removal,
    ETH_HLEN is used.
    
    Since the bonding header_ops are set only when the first enslaved
    device is attached, the above can lead to header_ops->create()
    being called with the wrong skb headroom in place.
    
    If bond0 is configured on top of ipoib devices, with the
    following commands:
    
    ifup bond0
    for slave in $BOND_SLAVES_LIST; do
            ip link set dev $slave nomaster
    done
    ping -c 1 <ip on bond0 subnet>
    
    we will obtain a skb_under_panic() with a similar call trace:
            skb_push+0x3d/0x40
            push_pseudo_header+0x17/0x30 [ib_ipoib]
            ipoib_hard_header+0x4e/0x80 [ib_ipoib]
            arp_create+0x12f/0x220
            arp_send_dst.part.19+0x28/0x50
            arp_solicit+0x115/0x290
            neigh_probe+0x4d/0x70
            __neigh_event_send+0xa7/0x230
            neigh_resolve_output+0x12e/0x1c0
            ip_finish_output2+0x14b/0x390
            ip_finish_output+0x136/0x1e0
            ip_output+0x76/0xe0
            ip_local_out+0x35/0x40
            ip_send_skb+0x19/0x40
            ip_push_pending_frames+0x33/0x40
            raw_sendmsg+0x7d3/0xb50
            inet_sendmsg+0x31/0xb0
            sock_sendmsg+0x38/0x50
            SYSC_sendto+0x102/0x190
            SyS_sendto+0xe/0x10
            do_syscall_64+0x67/0x180
            entry_SYSCALL64_slow_path+0x25/0x25
    
    This change addresses the issue avoiding updating the bonding device
    hard_header_len when the slaves list become empty, forbidding to
    shrink it below the value used by header_ops->create().
    
    The bug is there since commit 54ef31371407 ("[PATCH] bonding: Handle large
    hard_header_len") but the panic can be triggered only since
    commit fc791b633515 ("IB/ipoib: move back IB LL address into the hard
    header").
    
    Reported-by: Norbert P <noe@physik.uzh.ch>
    Fixes: 54ef31371407 ("[PATCH] bonding: Handle large hard_header_len")
    Fixes: fc791b633515 ("IB/ipoib: move back IB LL address into the hard header")
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit bb4a21dcb6fb57892eea7c941fdfd57e55ba5dbe
Author: Erez Shitrit <erezsh@mellanox.com>
Date:   Wed Feb 1 19:10:05 2017 +0200

    IB/IPoIB: Add destination address when re-queue packet
    
    commit 2b0841766a898aba84630fb723989a77a9d3b4e6 upstream.
    
    When sending packet to destination that was not resolved yet
    via path query, the driver keeps the skb and tries to re-send it
    again when the path is resolved.
    
    But when re-sending via dev_queue_xmit the kernel doesn't call
    to dev_hard_header, so IPoIB needs to keep 20 bytes in the skb
    and to put the destination address inside them.
    
    In that way the dev_start_xmit will have the correct destination,
    and the driver won't take the destination from the skb->data, while
    nothing exists there, which causes to packet be be dropped.
    
    The test flow is:
    1. Run the SM on remote node,
    2. Restart the driver.
    4. Ping some destination,
    3. Observe that first ICMP request will be dropped.
    
    Fixes: fc791b633515 ("IB/ipoib: move back IB LL address into the hard header")
    Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
    Signed-off-by: Noa Osherovich <noaos@mellanox.com>
    Signed-off-by: Leon Romanovsky <leon@kernel.org>
    Tested-by: Yuval Shaia <yuval.shaia@oracle.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 800a78f9e62bfd91473c306479a411cff2601f62 ......
	 orig commit -> c34f078675f505c4437919bb1897b1351f16a050 ......
checking d79e41188a1e20cb71fab70c7a76f7b0ab3ea01c ......
	 orig commit -> c929ea0b910355e1876c64431f3d5802f95b3d75 ......
checking edef1086bf094bbc6b35dc624e79ee6920215bf4 ......
	 orig commit -> a430607b2ef7c3be090f88c71cfcb1b3988aa7c0 ......
checking 0f64f22c0686ca66cb5d0c88d1322d7cf32e1986 ......
	 orig commit -> 059aa734824165507c65fd30a55ff000afd14983 ......
		 059aa734824165507c65fd30a55ff000afd14983 has problem. Fixes commit -> 406dab8450ec76eca88a1af2fc15d18a2b36ca49
commit 10bfb4c76c941fface83bd4695f19ce84510dbe0
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Jan 26 15:14:52 2017 -0500

    nfs: Fix "Don't increment lock sequence ID after NFS4ERR_MOVED"
    
    
    [ Upstream commit 406dab8450ec76eca88a1af2fc15d18a2b36ca49 ]
    
    Lock sequence IDs are bumped in decode_lock by calling
    nfs_increment_seqid(). nfs_increment_sequid() does not use the
    seqid_mutating_err() function fixed in commit 059aa7348241 ("Don't
    increment lock sequence ID after NFS4ERR_MOVED").
    
    Fixes: 059aa7348241 ("Don't increment lock sequence ID after ...")
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: Xuan Qi <xuan.qi@oracle.com>
    Cc: stable@vger.kernel.org # v3.7+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking bde741e9cc23b0ff443ff64706f11531202d4559 ......
	 orig commit -> 2ad5d52d42810bed95100a3d912679d8864421ec ......
checking acb63c8b576d9a853ffae2f25f21447be6f5c347 ......
	 orig commit -> 9aed02feae57bf7a40cb04ea0e3017cb7a998db4 ......
		 9aed02feae57bf7a40cb04ea0e3017cb7a998db4 has problem. Fixes commit -> a524c218bc94c705886a0e0fedeee45d1931da32
commit e871ea6bcf99097731fceff3e8e1c5ed05b04ae2
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Tue Feb 7 09:44:58 2017 -0800

    ARC: [arcompact] brown paper bag bug in unaligned access delay slot fixup
    
    commit a524c218bc94c705886a0e0fedeee45d1931da32 upstream.
    
    Reported-by: Jo-Philipp Wich <jo@mein.io>
    Fixes: 9aed02feae57bf7 ("ARC: [arcompact] handle unaligned access delay slot")
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 42ad7663677d886b6bd95f64c881cafdff24399a ......
	 orig commit -> 36425cd67052e3becf325fd4d3ba5691791ef7e4 ......
checking bca1a95c9e208271e7af7781862f779a9fbaf740 ......
	 orig commit -> befa60113ce7ea270cb51eada28443ca2756f480 ......
checking 63fe33a7842883bae9f526b324eb5d807a098ee9 ......
	 orig commit -> c97c52be78b8463ac5407f1cf1f22f8f6cf93a37 ......
checking bae49e72f95155dd22ee6e80f6b4eb360469b7d6 ......
	 orig commit -> 9dce990d2cf57b5ed4e71a9cdbd7eae4335111ff ......
checking 8637de3a318df6b84a91c7d3b988fab8668f94ee ......
	 orig commit -> b4cfe3971f6eab542dd7ecc398bfa1aeec889934 ......
checking d65032ab06f457f831329a0241f70e4ff05bb23e ......
	 orig commit -> 950eabbd6ddedc1b08350b9169a6a51b130ebaaf ......
checking d1b232c2ce53d35dfb9c9e7447eeef42cea20e42 ......
	 orig commit -> ff9f8a7cf935468a94d9927c68b00daae701667e ......
checking f11e8bf8e99bf3f7364135a0d15549586d6c6933 ......
	 orig commit -> d51e9894d27492783fc6d1b489070b4ba66ce969 ......
checking c83ad9703e71720bb5001daab7cbaf9b8d59b084 ......
	 orig commit -> fdf35a6b22247746a7053fc764d04218a9306f82 ......
checking 23bc4e136bca4607f39d65df1ee8ca64359ea2a6 ......
	 orig commit -> fd7c99142d77dc4a851879a66715abf12a3193fb ......
checking 63db7c91a3c0ebe0e291feea53e4c63391db9465 ......
	 orig commit -> 2dc705a9930b4806250fbf5a76e55266e59389f2 ......
