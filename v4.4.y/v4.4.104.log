Check from v4.4.104 to v4.4.105
Commit count: 48
checking 69b0bf95a51eb4b0890b3979531aed932cf51d7f ......
checking da57b1f7e74fe050f2996614b19fb780f4174639 ......
	 orig commit -> d86b5672b1adb98b4cdd6fbf0224bbfb03db6e2e ......
checking e1cadf7c4af2e51f5ac6f078a128d4b71bbaa601 ......
	 orig commit -> 1d5a31582ef046d3b233f0da1a68ae26519b2f0a ......
checking 43135100f117f73177ed8687cdead02772b4e09f ......
	 orig commit -> 446f666da9f019ce2ffd03800995487e79a91462 ......
checking c0493eb552e0ad84c86e8fb3b9b9817c57a52d18 ......
	 orig commit -> 57999d1107c1e60c2ca7088f2ac0f819e2f554b3 ......
checking 2ee8d2acf3efc2ddcd571845e8663a101cdde86e ......
	 orig commit -> 1129d270cbfbb7e2b1ec3dede4a13930bdd10e41 ......
		 1129d270cbfbb7e2b1ec3dede4a13930bdd10e41 has problem. Fixes commit -> 57999d1107c1e60c2ca7088f2ac0f819e2f554b3
commit c0493eb552e0ad84c86e8fb3b9b9817c57a52d18
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Sep 22 23:43:25 2017 +0300

    USB: devio: Prevent integer overflow in proc_do_submiturb()
    
    commit 57999d1107c1e60c2ca7088f2ac0f819e2f554b3 upstream.
    
    There used to be an integer overflow check in proc_do_submiturb() but
    we removed it.  It turns out that it's still required.  The
    uurb->buffer_length variable is a signed integer and it's controlled by
    the user.  It can lead to an integer overflow when we do:
    
            num_sgs = DIV_ROUND_UP(uurb->buffer_length, USB_SG_SIZE);
    
    If we strip away the macro then that line looks like this:
    
            num_sgs = (uurb->buffer_length + USB_SG_SIZE - 1) / USB_SG_SIZE;
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    It's the first addition which can overflow.
    
    Fixes: 1129d270cbfb ("USB: Increase usbfs transfer limit")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 9d812f7bef8c01cd8ca1b57e1e3c3df4bc8ffd34 ......
	 orig commit -> 81cf4a45360f70528f1f64ba018d61cb5767249a ......
		 81cf4a45360f70528f1f64ba018d61cb5767249a has problem. Fixes commit -> 07b9f12864d16c3a861aef4817eb1efccbc5d0e6
commit 0ceb7a66392df476b61f8e3c84100710588e56bd
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Dec 19 11:14:42 2017 +0200

    USB: Fix off by one in type-specific length check of BOS SSP capability
    
    commit 07b9f12864d16c3a861aef4817eb1efccbc5d0e6 upstream.
    
    USB 3.1 devices are not detected as 3.1 capable since 4.15-rc3 due to a
    off by one in commit 81cf4a45360f ("USB: core: Add type-specific length
    check of BOS descriptors")
    
    It uses USB_DT_USB_SSP_CAP_SIZE() to get SSP capability size which takes
    the zero based SSAC as argument, not the actual count of sublink speed
    attributes.
    
    USB3 spec 9.6.2.5 says "The number of Sublink Speed Attributes = SSAC + 1."
    
    The type-specific length check patch was added to stable and needs to be
    fixed there as well
    
    Fixes: 81cf4a45360f ("USB: core: Add type-specific length check of BOS descriptors")
    CC: Masakazu Mokuno <masakazu.mokuno@gmail.com>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking f044af8c1dc3f12d933dfae4e51ab2ebab95e5db ......
	 orig commit -> 446fa3a95df1e8b78f25e1babc41e46edd200821 ......
checking ddaa1ae2eb7ffb4e270fdc9593c3d1138f61fb31 ......
	 orig commit -> faee822c5a7ab99de25cd34fcde3f8d37b6b9923 ......
checking a1f03a9bcfa4becab9255c15a27caff7d9d4f667 ......
	 orig commit -> 80e457699a8dbdd70f2d26911e46f538645c55fc ......
checking 6a85ba4157a08350657f7e5d3bc20e9d3acc2b60 ......
	 orig commit -> 973593a960ddac0f14f0d8877d2d0abe0afda795 ......
checking 40012163e52ac30f64e0cbb1472040fd292f8e78 ......
	 orig commit -> c4baa4a5870cb02f713def1620052bfca7a82bbb ......
	 orig commit -> 28f5a8a7c033cbf3e32277f4cc9c6afd74f05300 ......
checking 33621da4d4ef5901e81b610b2a8ad565ed666035 ......
	 orig commit -> 01f8902bcf3ff124d0aeb88a774180ebcec20ace ......
checking 5d036ccddc5d54e540c0bd4fe4c242f9e0f3aa18 ......
	 orig commit -> e2e004acc7cbe3c531e752a270a74e95cde3ea48 ......
checking cc4add389789f89018fa6705cd8e02d6b6cab67d ......
	 orig commit -> 0911d0041c22922228ca52a977d7b0b0159fee4b ......
checking 1b7dbabf0242e7742decae10555886474de8628d ......
	 orig commit -> 56d806222ace4c3aeae516cd7a855340fb2839d8 ......
checking bc42f67b73cb875d63ea450cac0ec389b7ed9f21 ......
	 orig commit -> 91539eb1fda2d530d3b268eef542c5414e54bf1a ......
checking ca083606101930bf1bc1f539fec73f3dff869895 ......
	 orig commit -> 35e22e49a5d6a741ebe7f2dd280b2052c3003ef7 ......
checking e5afc84f644c1eb23a58f2d8609d061bdc0fe7b8 ......
	 orig commit -> 0e73fc9a56f22f2eec4d2b2910c649f7af67b74d ......
checking 7e9236c001520e38379a4f1da99a621d75794384 ......
	 orig commit -> 11d8bcef7a0399e1d2519f207fd575fc404306b4 ......
checking e26d58f897cad5132c98a909bc205de4ab6ce2ea ......
	 orig commit -> c6180a6237174f481dc856ed6e890d8196b6f0fb ......
checking 48222dd037f5410402a16f8bd41ec7b4d4446d03 ......
	 orig commit -> 63e41226afc3f7a044b70325566fa86ac3142538 ......
checking f2fb416f4af6f957caa7efc9ed51c37cb1e40a2b ......
	 orig commit -> 4b09ec4b14a168bf2c687e1f598140c3c11e9222 ......
checking 7228df818d90cd9a79481f003055130597ca4a68 ......
	 orig commit -> 18a3ed59d09cf81a6447aadf6931bf0c9ffec5e0 ......
checking 1bb50d02a8d3161947d213e9627a1a98fea60ac1 ......
	 orig commit -> ce7e40c432ba84da104438f6799d460a4cad41bc ......
checking c73b58cfa83e6aac20f075fe1d9d94047da80a25 ......
	 orig commit -> 93e246f783e6bd1bc64fdfbfe68b18161f69b28e ......
checking e6533243f74fd2ca85387e1d332eecdf961931e4 ......
	 orig commit -> 657279778af54f35e54b07b6687918f254a2992c ......
checking e6f1055319929a7005b83a95c0e65444201964c2 ......
	 orig commit -> 38e5a85562a6cd911fc26d951d576551a688574c ......
checking 3a44ade54473ebda10e12dce08b203d5a60308ae ......
	 orig commit -> bb7da333d0a9f3bddc08f84187b7579a3f68fd24 ......
checking 8633eec0ee08d6dd4148941bba4ac2b4d918826b ......
	 orig commit -> 5bb4fc2d8641219732eb2bb654206775a4219aca ......
checking 7317cb116754947d459bf709e4dccad31baa64bb ......
	 orig commit -> 22905582f6dd4bbd0c370fe5732c607452010c04 ......
checking 1c4d7600390b79b283022978a024fdf6cc1a6f59 ......
	 orig commit -> b00bebbc301c8e1f74f230dc82282e56b7e7a6db ......
checking c86fa9ed3a0fc8a48ee07309f1ea13a7df2b149f ......
	 orig commit -> a8e9b186f153a44690ad0363a56716e7077ad28c ......
checking c2e1be144805266fbd75fa29ad896b9671fdae8e ......
	 orig commit -> da20ab35180780e4a6eadc804544f1fa967f3567 ......
checking ecd996c24a790b3c30346e45076b55ded497f207 ......
	 orig commit -> 0ab84da2e076948c49d36197ee7d254125c53eab ......
checking 86b9d66d1f3f4121853f46452d0a756217a55ea0 ......
	 orig commit -> ce035409bfa892a2fabb89720b542e1b335c3426 ......
checking b6ca48b5cd08a6dbeab8249e83dfd16b9eb87184 ......
	 orig commit -> 36735783fdb599c94b9c86824583df367c65900b ......
checking a96c19f5ba09e839eb6af1bccd8cea0bc00fbabc ......
	 orig commit -> 3236a965486ba0c6043cf2c7b51943d8b382ae29 ......
checking 429feb597df3cefe218ed25ad7861e721c09894a ......
	 orig commit -> fec8f5ae1715a01c72ad52cb2ecd8aacaf142302 ......
checking 93f45d8c67dc914ed0d83b02549474759bdfc1ac ......
	 orig commit -> 48070c73058be6de9c0d754d441ed7092dfc8f12 ......
checking 80f93e24ecfcbbb95667e7e65f75e7646fd0905e ......
	 orig commit -> ebe7c0a7be92bbd34c6ff5b55810546a0ee05bee ......
checking 71ce1cac5b4db3e4004db76e3b61f47d7558438e ......
	 orig commit -> c654b21ede93845863597de9ad774fd30db5f2ab ......
checking 9e51ee1b76efc7b5e9404010793a39fde0e03cb7 ......
	 orig commit -> 8d9047f8b967ce6181fd824ae922978e1b055cc0 ......
checking ef3567cc5284b4171e5eb86637c55a72e50ef3cd ......
	 orig commit -> 3bfd1300abfe3adb18e84a89d97a0e82a22124bb ......
checking a8293de0ee1f91f73f908ca522e038cab2a40b13 ......
	 orig commit -> e43a12f1793ae1fe006e26fe9327a8840a92233c ......
checking 636b080991ee8511ad55a670da379f1123c7fc0b ......
	 orig commit -> 7fee72d5e8f1e7b8d8212e28291b1a0243ecf2f1 ......
checking 3f7477e64478c7d22642a97c25eb43649d2a480c ......
	 orig commit -> e393aa2446150536929140739f09c6ecbcbea7f0 ......
checking f80f34d8ba92b29f84228f91f9b6c0e0fca5c641 ......
	 orig commit -> d59b23795933678c9638fd20c942d2b4f3cd6185 ......
		 d59b23795933678c9638fd20c942d2b4f3cd6185 has problem. Fixes commit -> e393aa2446150536929140739f09c6ecbcbea7f0
commit 3f7477e64478c7d22642a97c25eb43649d2a480c
Author: Rui Hua <huarui.dev@gmail.com>
Date:   Fri Nov 24 15:14:26 2017 -0800

    bcache: recover data from backing when data is clean
    
    commit e393aa2446150536929140739f09c6ecbcbea7f0 upstream.
    
    When we send a read request and hit the clean data in cache device, there
    is a situation called cache read race in bcache(see the commit in the tail
    of cache_look_up(), the following explaination just copy from there):
    The bucket we're reading from might be reused while our bio is in flight,
    and we could then end up reading the wrong data. We guard against this
    by checking (in bch_cache_read_endio()) if the pointer is stale again;
    if so, we treat it as an error (s->iop.error = -EINTR) and reread from
    the backing device (but we don't pass that error up anywhere)
    
    It should be noted that cache read race happened under normal
    circumstances, not the circumstance when SSD failed, it was counted
    and shown in  /sys/fs/bcache/XXX/internal/cache_read_races.
    
    Without this patch, when we use writeback mode, we will never reread from
    the backing device when cache read race happened, until the whole cache
    device is clean, because the condition
    (s->recoverable && (dc && !atomic_read(&dc->has_dirty))) is false in
    cached_dev_read_error(). In this situation, the s->iop.error(= -EINTR)
    will be passed up, at last, user will receive -EINTR when it's bio end,
    this is not suitable, and wield to up-application.
    
    In this patch, we use s->read_dirty_data to judge whether the read
    request hit dirty data in cache device, it is safe to reread data from
    the backing device when the read request hit clean data. This can not
    only handle cache read race, but also recover data when failed read
    request from cache device.
    
    [edited by mlyle to fix up whitespace, commit log title, comment
    spelling]
    
    Fixes: d59b23795933 ("bcache: only permit to recovery read error when cache device is clean")
    Signed-off-by: Hua Rui <huarui.dev@gmail.com>
    Reviewed-by: Michael Lyle <mlyle@lyle.org>
    Reviewed-by: Coly Li <colyli@suse.de>
    Signed-off-by: Michael Lyle <mlyle@lyle.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
