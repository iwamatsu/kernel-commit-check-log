Check from v4.4.98 to v4.4.99
Commit count: 29
checking 0cbac004e67307949714c176c8a7af9c1da980b9 ......
checking e8d650563c5fc1ef9f862a8122397e18043fd51b ......
	 orig commit -> 93dc1774d2a4c7a298d5cdf78cc8acdcb7b1428d ......
checking 01000c56caccf36ddd253bb15036a1cbb93ad27f ......
	 orig commit -> 6f48655facfd7f7ccfe6d252ac0fe319ab02e4dd ......
	 orig commit -> 01d4d673558985d9a118e1e05026633c3e2ade9b ......
checking 4063c209334911c61fa3807dbe4e7a9c81361b8d ......
	 orig commit -> 59b6986dbfcdab96a971f9663221849de79a7556 ......
checking 7ecc076a5d51776c7057ef57277badfd373f454d ......
	 orig commit -> 9029679f66d976f8c720eb03c4898274803c9923 ......
checking d27383faf14469c5ec600a3d92aa4f1d81282472 ......
	 orig commit -> d01332f1acacc0cb43a61f4244dd2b846d4cd585 ......
checking c8f13916c4c9e03dd5c04a44edd4702b97b1e96d ......
	 orig commit -> 47b2c3fff4932e6fc17ce13d51a43c6969714e20 ......
checking 11fa3353205e732274bdf7d4c41a510b11397a21 ......
	 orig commit -> 06f877d613be3621604c2520ec0351d9fbdca15f ......
		 06f877d613be3621604c2520ec0351d9fbdca15f has problem. Fixes commit -> 1ad98e9d1bdf4724c0a8532fabd84bf3c457c2bc
checking 6f8048cd59d7b3d0b2abb38fbdedcaa5bf69ed28 ......
	 orig commit -> a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf ......
		 a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf has problem. Fixes commit -> 06f877d613be3621604c2520ec0351d9fbdca15f
commit 11fa3353205e732274bdf7d4c41a510b11397a21
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking 13eddc67565a7e582c3a1f87627842e0da80291c ......
	 orig commit -> c92e8c02fe664155ac4234516e32544bec0f113d ......
		 c92e8c02fe664155ac4234516e32544bec0f113d has problem. Fixes commit -> 06f877d613be3621604c2520ec0351d9fbdca15f
a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf
commit 11fa3353205e732274bdf7d4c41a510b11397a21
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f8048cd59d7b3d0b2abb38fbdedcaa5bf69ed28
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Oct 22 12:33:57 2017 -0700

    tcp/dccp: fix lockdep splat in inet_csk_route_req()
    
    
    [ Upstream commit a6ca7abe53633d08eea1c6756cb49c9b2d4c90bf ]
    
    This patch fixes the following lockdep splat in inet_csk_route_req()
    
      lockdep_rcu_suspicious
      inet_csk_route_req
      tcp_v4_send_synack
      tcp_rtx_synack
      inet_rtx_syn_ack
      tcp_fastopen_synack_time
      tcp_retransmit_timer
      tcp_write_timer_handler
      tcp_write_timer
      call_timer_fn
    
    Thread running inet_csk_route_req() owns a reference on the request
    socket, so we have the guarantee ireq->ireq_opt wont be changed or
    freed.
    
    lockdep can enforce this invariant for us.
    
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit 11fa3353205e732274bdf7d4c41a510b11397a21
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Oct 24 08:20:31 2017 -0700

    tcp/dccp: fix other lockdep splats accessing ireq_opt
    
    
    [ Upstream commit 06f877d613be3621604c2520ec0351d9fbdca15f ]
    
    In my first attempt to fix the lockdep splat, I forgot we could
    enter inet_csk_route_req() with a freshly allocated request socket,
    for which refcount has not yet been elevated, due to complex
    SLAB_TYPESAFE_BY_RCU rules.
    
    We either are in rcu_read_lock() section _or_ we own a refcount on the
    request.
    
    Correct RCU verb to use here is rcu_dereference_check(), although it is
    not possible to prove we actually own a reference on a shared
    refcount :/
    
    In v2, I added ireq_opt_deref() helper and use in three places, to fix other
    possible splats.
    
    [   49.844590]  lockdep_rcu_suspicious+0xea/0xf3
    [   49.846487]  inet_csk_route_req+0x53/0x14d
    [   49.848334]  tcp_v4_route_req+0xe/0x10
    [   49.850174]  tcp_conn_request+0x31c/0x6a0
    [   49.851992]  ? __lock_acquire+0x614/0x822
    [   49.854015]  tcp_v4_conn_request+0x5a/0x79
    [   49.855957]  ? tcp_v4_conn_request+0x5a/0x79
    [   49.858052]  tcp_rcv_state_process+0x98/0xdcc
    [   49.859990]  ? sk_filter_trim_cap+0x2f6/0x307
    [   49.862085]  tcp_v4_do_rcv+0xfc/0x145
    [   49.864055]  ? tcp_v4_do_rcv+0xfc/0x145
    [   49.866173]  tcp_v4_rcv+0x5ab/0xaf9
    [   49.868029]  ip_local_deliver_finish+0x1af/0x2e7
    [   49.870064]  ip_local_deliver+0x1b2/0x1c5
    [   49.871775]  ? inet_del_offload+0x45/0x45
    [   49.873916]  ip_rcv_finish+0x3f7/0x471
    [   49.875476]  ip_rcv+0x3f1/0x42f
    [   49.876991]  ? ip_local_deliver_finish+0x2e7/0x2e7
    [   49.878791]  __netif_receive_skb_core+0x6d3/0x950
    [   49.880701]  ? process_backlog+0x7e/0x216
    [   49.882589]  __netif_receive_skb+0x1d/0x5e
    [   49.884122]  process_backlog+0x10c/0x216
    [   49.885812]  net_rx_action+0x147/0x3df
    
    Fixes: a6ca7abe53633 ("tcp/dccp: fix lockdep splat in inet_csk_route_req()")
    Fixes: c92e8c02fe66 ("tcp/dccp: fix ireq->opt races")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: kernel test robot <fengguang.wu@intel.com>
    Reported-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
checking b9b0c99a426ad92fa42f0702bb5bf5d0f996cbd8 ......
	 orig commit -> f3594f0a7ea36661d7fd942facd7f31a64245f1a ......
checking 9bae2ffb87d69aa9b71248724376956eb8d2e656 ......
	 orig commit -> 6151b8b37b119e8e3a8401b080d532520c95faf4 ......
checking 4b5bb7723da1da2198a5c80e47ecfceb88995ae3 ......
	 orig commit -> d04adf1b355181e737b6b1e23d801b07f0b7c4c0 ......
		 d04adf1b355181e737b6b1e23d801b07f0b7c4c0 has problem. Fixes commit -> a8dd397903a6e57157f6265911f7d35681364427
checking bcb3b90cf3c8369ce0ca48b6e4f67eb57abb1438 ......
	 orig commit -> 5c25f65fd1e42685f7ccd80e0621829c105785d9 ......
checking 5c8a0850bae234f3f58d166afd75c7e02c95c5c6 ......
	 orig commit -> f8d20b46ce55cf40afb30dcef6d9288f7ef46d9b ......
checking 93b12f202a4eae6856e2f67e002c8e4363600d4a ......
	 orig commit -> 0f5da659d8f1810f44de14acf2c80cd6499623a0 ......
checking 84237c54b2399076c7a22b7818b0a414099d02d0 ......
	 orig commit -> 864e2a1f8aac05effac6063ce316b480facb46ff ......
checking d552c8c5007afe1a614f8bc92507d8789aa70307 ......
	 orig commit -> 509c7a1ecc8601f94ffba8a00889fefb239c00c6 ......
		 509c7a1ecc8601f94ffba8a00889fefb239c00c6 has problem. Fixes commit -> 57f015f5eccf25fd4a3336fe3cbbee920a8fba6f
checking ef3a12f1dc4ae0c1d46476fe536a443b0582ae5f ......
	 orig commit -> 1cc276cec9ec574d41cf47dfc0f51406b6f26ab4 ......
checking 4b27fe34a226dd9087cb2e93161ffec03952c05a ......
	 orig commit -> 0ad646c81b2182f7fa67ec0c8c825e0ee165696d ......
checking 196f4755cc821f09f3ef2ff8cf54bbf34b6ab76c ......
	 orig commit -> 5903f594935a3841137c86b9d5b75143a5b7121c ......
checking 71c4a0fc35768b59b0fbd88c3eda719ed924237c ......
	 orig commit -> 2b7cda9c35d3b940eb9ce74b30bbd5eb30db493d ......
checking 735818a8b45c90a6210454b3bd413b678a60d018 ......
	 orig commit -> 93161922c658c714715686cd0cf69b090cb9bf1d ......
checking 1e98fd54c356bb2bcf827a74949c9372c455409f ......
	 orig commit -> fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57 ......
checking b7c625ce6d279bf3e138c25c0cd3f595923825f3 ......
	 orig commit -> ea04efee7635c9120d015dcdeeeb6988130cb67a ......
checking de46c1adbea694109036d3e7dee1fa6250b72660 ......
	 orig commit -> 7c80f9e4a588f1925b07134bb2e3689335f6c6d8 ......
checking c93df40f3c73a74226e59bcfb1edb57ec979d0a7 ......
	 orig commit -> cfbb0d90a7abb289edc91833d0905931f8805f12 ......
checking cdac2028c90112354febf9fd6d50ae70259cae0b ......
	 orig commit -> 2bdd713b92a9cade239d3c7d15205a09f556624d ......
checking 6440f0ee8a1779f53526bccb9de00914daeb9094 ......
	 orig commit -> fdf7cb4185b60c68e1a75e61691c4afdc15dea0e ......
		 fdf7cb4185b60c68e1a75e61691c4afdc15dea0e has problem. Fixes commit -> cfbb0d90a7abb289edc91833d0905931f8805f12
2bdd713b92a9cade239d3c7d15205a09f556624d
commit cdac2028c90112354febf9fd6d50ae70259cae0b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 20:32:07 2017 +0200

    mac80211: use constant time comparison with keys
    
    commit 2bdd713b92a9cade239d3c7d15205a09f556624d upstream.
    
    Otherwise we risk leaking information via timing side channel.
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
commit c93df40f3c73a74226e59bcfb1edb57ec979d0a7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Oct 24 21:12:13 2017 +0200

    mac80211: don't compare TKIP TX MIC key in reinstall prevention
    
    commit cfbb0d90a7abb289edc91833d0905931f8805f12 upstream.
    
    For the reinstall prevention, the code I had added compares the
    whole key. It turns out though that iwlwifi firmware doesn't
    provide the TKIP TX MIC key as it's not needed in client mode,
    and thus the comparison will always return false.
    
    For client mode, thus always zero out the TX MIC key part before
    doing the comparison in order to avoid accepting the reinstall
    of the key with identical encryption and RX MIC key, but not the
    same TX MIC key (since the supplicant provides the real one.)
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cdac2028c90112354febf9fd6d50ae70259cae0b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Oct 17 20:32:07 2017 +0200

    mac80211: use constant time comparison with keys
    
    commit 2bdd713b92a9cade239d3c7d15205a09f556624d upstream.
    
    Otherwise we risk leaking information via timing side channel.
    
    Fixes: fdf7cb4185b6 ("mac80211: accept key reinstall without changing anything")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Cc: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
